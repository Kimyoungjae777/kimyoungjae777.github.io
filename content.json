{"meta":{"title":"영재의 개발일지","subtitle":"","description":"","author":"KimYoungJae","url":"https://kimyoungjae777.github.io","root":"/"},"pages":[],"posts":[{"title":"","slug":"Java추상메소드","date":"2023-04-14T14:32:29.829Z","updated":"2023-04-14T05:31:44.000Z","comments":true,"path":"2023/04/14/Java추상메소드/","link":"","permalink":"https://kimyoungjae777.github.io/2023/04/14/Java%EC%B6%94%EC%83%81%EB%A9%94%EC%86%8C%EB%93%9C/","excerpt":"","text":"JAVA 추상메소드추상메서드는 빈 껍데기 이다. ⇒ 선언은 되어있는데, 코드가 구현이 안되어있는 것 추상클래스 추상클래스를 상속받은 클래스는 추상 클래스 안에 있는 모든 추상 메서드를 구현해야한다. 인터페이스 VS 추상클래스 인터페이스 - 추상메서드 추상클래스&#x3D; 추상메서드 +일반메서드 추상 클래스는 상속을 받아서 기능을 확장하는데 컨셉이 있는것!!인터페이스는 설계도로써 전체적인 틀을 잡거나 이렇게 만들라고 규칙을 정하는데 중점을 둔 것","categories":[],"tags":[]},{"title":"","slug":"Variables","date":"2023-04-14T14:29:10.436Z","updated":"2023-04-14T14:29:10.436Z","comments":true,"path":"2023/04/14/Variables/","link":"","permalink":"https://kimyoungjae777.github.io/2023/04/14/Variables/","excerpt":"","text":"title: “생활코딩(변수)-20,21,22,23”author: “Young Jae Kim”date: ‘2022-02-02’output: html_document: keep_md: truecategories: Development 생활코딩-자바tags: Development 생활코딩-자바 생활코딩(변수)-20,21,22,23변수 영어로는 Variable 로 (문자나 숫자 같은) 데이터를 담는 컨테이너다. 여기에 담겨진 데이터는 다른 데이터로 바꿀 수 있다. 변수는 마치(사람이 쓰는 언어인) 자연어에서 대명사와 비슷한 역할을 한다 . 정수와 실수- 123int d; d=a+c; System.out.println(d); output → error ⇒ int 에 int+double 을 하니까 type mismatch 가 일어난다. 문자열 변수 동시선언 가능 1234String a,b;a=&quot;coding&quot;b=&quot;everybody&quot;syso(a+b); output - codingeverybody","categories":[],"tags":[]},{"title":"Select from world","slug":"selectFromWorld","date":"2023-01-29T15:00:00.000Z","updated":"2023-04-14T14:29:10.452Z","comments":true,"path":"2023/01/30/selectFromWorld/","link":"","permalink":"https://kimyoungjae777.github.io/2023/01/30/selectFromWorld/","excerpt":"","text":"SELECT from World1.Read the notes about this table. Observe the result of running this SQL command to show the name, continent and population of all countries. &lt;데이터를 관찰하라&gt; 12select name,continent,populationfrom world 2. How to use WHERE to filter records. Show the name for the countries that have a population of at least 200 million. 200 million is 200000000, there are eight zerosrds 인구가 최소 200millon 이상인 나라이름을 출력하라 12SELECT name FROM worldWHERE population &gt;= 200000000 3.Give the name and the per capita GDP for those countries with a population of at least 200 million. 인구가 200000000 이상인 나라 조건에서 , 인구별 1인당 gdp를 구하여라 123select name,GDP/populationfrom world where population&gt;=200000000 4.Show the name and population in millions for the countries of the continent ‘South America’. Divide the population by 1000000 to get population in millions. ‘South America’ 대륙의 이름과 인구를 100만으로 나눈것을 출력하라 123select name,population/1000000from world where continent=&#x27;South America&#x27; 5.Show the name and population for France, Germany, Italy ‘France’,’Germany’,’Italy’ 이름을 가진 나라들의 이름과 인구를 출력하라. 123select name,population from worldwhere name IN(&#x27;France&#x27;,&#x27;Germany&#x27;,&#x27;Italy&#x27;) IN 연산자는 OR 역할을 한다. NAME 에 괄호 안의 문자열이 들어간 NAME을 뽑아낸다. 6.Show the countries which have a name that includes the word ‘United’ ‘United’ 문자열을 포함하는 나라의 이름을 출력하라 123select name from worldwhere name like(&#x27;%United%&#x27;) 7.Two ways to be big: A country is big if it has an area of more than 3 million sq km or it has a population of more than 250 million. Show the countries that are big by area or big by population. Show name, population and area. 위에서 언급한 대도시의 조건에 부합하는 name,population,area 를 출력하라 123select name,population,areafrom world where area&gt;3000000 or population&gt;250000000 OR 연산자 사용 !! 8.Exclusive OR (XOR). Show the countries that are big by area (more than 3 million) or big by population (more than 250 million) but not both. Show name, population and area. Australia has a big area but a small population, it should be included. Indonesia has a big population but a small area, it should be included. China has a big population and big area, it should be excluded. United Kingdom has a small population and a small area, it should be excluded XOR 문제 A 상황 과 B상황을 구하되 , A,B 둘다 일어나는 상황은 제외하라 123select name,population,areafrom world where (area&gt;3000000 or population&gt;250000000) and NOT (area&gt;3000000 and population&gt;250000000) 괄호를 묶어서 원래 대도시의 조건을 넣어준다. 그리고 AND 연산자로 BOTH 에 소하는 것들은 제외해준다. 9.Show the name and population in millions and the GDP in billions for the countries of the continent ‘South America’. Use the ROUND function to show the values to two decimal places. For South America show population in millions and GDP in billions both to 2 decimal places. South America 의 100만명당 인구를 출력하라 그리고 gdp 를 2째자리 까지 반올림 하여라 . 123select name,round(population/1000000,2),round(gdp/1000000000,2)from world where continent=&#x27;South America&#x27; 10.Show the name and per-capita GDP for those countries with a GDP of at least one trillion (1000000000000; that is 12 zeros). Round this value to the nearest 1000. Show per-capita GDP for the trillion dollar countries to the nearest $1000. gdp가 최소 1000000000000 인 나라의 1인당 gdp를 3자리까지 반올림하여 표현하리 123select name,round(gdp/population,-3) from world where gdp&gt;=1000000000000 11.Greece has capital Athens. Each of the strings ‘Greece’, and ‘Athens’ has 6 characters. Show the name and capital where the name and the capital have the same number of characters. You can use the LENGTH function to find the number of characters in a string For Microsoft SQL Server the function LENGTH is LEN (NAME 과 CAPITAL 의 숫자 길이가 같은 NAME 과 CAPITAL 을 출력하라) 123SELECT name,capitalfrom world where LEN(name)=LEN(capital) 12.The capital of Sweden is Stockholm. Both words start with the letter ‘S’. Show the name and the capital where the first letters of each match. Don’t include countries where the name and the capital are the same word. You can use the function LEFT to isolate the first character. You can use &lt;&gt; as the NOT EQUALS operator. (NAME 과 CAPITAL 의 왼쪽에서 첫번째 글자가 같은것을 출력하며, 이름과 수도가 같지 않은 것들을 출력하라) 123SELECT NAME,CAPITAL FROM WORLD WHERE LEFT(NAME,1)=LEFT(CAPITAL,1) AND NOT(NAME=CAPITAL) 13.Equatorial Guinea and Dominican Republic have all of the vowels (a e i o u) in the name. They don’t count because they have more than one word in the name. Find the country that has all the vowels and no spaces in its name. You can use the phrase name NOT LIKE &#39;%a%&#39; to exclude characters from your results. The query shown misses countries like Bahamas and Belarus because they contain at least one ‘a’ (a,e,i,o,u 를 모두 포함하며, 띄어쓰기를 포함하지 않는 나라를 출력하라.) 123456789SELECT NAME FROM WORLDWHERE NAME LIKE(&#x27;%a%&#x27;) andNAME LIKE(&#x27;%i%&#x27;) andNAME LIKE(&#x27;%e%&#x27;) andNAME LIKE(&#x27;%o%&#x27;) andNAME LIKE(&#x27;%u%&#x27;) andNAME NOT LIKE(&#x27;% %&#x27;)","categories":[{"name":"Development","slug":"Development","permalink":"https://kimyoungjae777.github.io/categories/Development/"},{"name":"SqlZoo","slug":"Development/SqlZoo","permalink":"https://kimyoungjae777.github.io/categories/Development/SqlZoo/"}],"tags":[{"name":"Development","slug":"Development","permalink":"https://kimyoungjae777.github.io/tags/Development/"},{"name":"SQLZOO","slug":"SQLZOO","permalink":"https://kimyoungjae777.github.io/tags/SQLZOO/"}],"author":"Young Jae Kim"},{"title":"The current branch master has no upstream branch","slug":"the_Current~","date":"2023-01-23T00:00:00.000Z","updated":"2023-04-14T14:29:10.460Z","comments":true,"path":"2023/01/23/the_Current~/","link":"","permalink":"https://kimyoungjae777.github.io/2023/01/23/the_Current~/","excerpt":"","text":"The current branch master has no upstream branch. 오류의 원인은 처음 만들고 원격 저장소에 대한 기본 브랜치를 설정을 안 해주었기 때문에 생기는 오류 . $ git push —set-upstream origin main 이 코드를 통해 기본 브랜치를 main 으로 설정해준 뒤 push 를 하면 오류가 생겨난다.","categories":[{"name":"Development","slug":"Development","permalink":"https://kimyoungjae777.github.io/categories/Development/"},{"name":"git_error","slug":"Development/git-error","permalink":"https://kimyoungjae777.github.io/categories/Development/git-error/"}],"tags":[{"name":"Machinelearning","slug":"Machinelearning","permalink":"https://kimyoungjae777.github.io/tags/Machinelearning/"},{"name":"git_error","slug":"git-error","permalink":"https://kimyoungjae777.github.io/tags/git-error/"}],"author":"Young Jae Kim"},{"title":"Select name","slug":"SelectName","date":"2023-01-20T15:00:00.000Z","updated":"2023-04-14T14:29:10.424Z","comments":true,"path":"2023/01/21/SelectName/","link":"","permalink":"https://kimyoungjae777.github.io/2023/01/21/SelectName/","excerpt":"","text":"SELECT NAME1.You can use WHERE name LIKE &#39;B%&#39; to find the countries that start with “B”. The % is a wild-card it can match any characters Find the country that start with Y (Y 로 시작하는 나라의 이름을 출력하라.) 123select name from worldWHERE name like &#x27;Y%&#x27; 2.Find the countries that end with y (Y로 끝나는 나라의 이름을 출력하라) 12SELECT name from worldwhere name like &#x27;%y&#x27; 3.Luxembourg has an x - so does one other country. List them both. Find the countries that contain the letter x (x 라는 문자를 포함하는 나라를 출력해라) 123select name from worldwhere name &#x27;%x%&#x27; 4.Iceland, Switzerland end with land - but are there others? Find the countries that end with land (마지막 글자가 land로 끝나는 나라를 출력하라) 123select namefrom world where name like &#x27;%land&#x27; 5.Columbia starts with a C and ends with ia - there are two more like this. Find the countries that start with C and end with ia (C로 시작해서 -ia 로 끝나는 나라를 출력하라) 1234select name from worldwhere name like &#x27;C%ia&#x27; 6.Greece has a double e - who has a double o? Find the country that has oo in the name (oo 를 가지는 나라를 출력하라) 1234select name from world where name like &#x27;%oo%&#x27; 7.Bahamas has three a - who else? Find the countries that have three or more a in the name (a 를 3 개나 3개이상 가진 나라를 출력하라) 12select name from world where name like &#x27;%a%a%a%&#x27; 8.India and Angola have an n as the second character. You can use the underscore as a single character wildcard. **SELECT** name **FROM** world **WHERE** name **LIKE** &#39;_n%&#39; **ORDER** **BY** name Find the countries that have “t” as the second character. (t 가 두번째 글자에 들어가는 나라를 찾아라) 12select name from world where name like &#x27;_t%&#x27; 9.Lesotho and Moldova both have two o characters separated by two other characters. Find the countries that have two “o” characters separated by two others. 123select name from world where name like &#x27;%o__o%&#x27; 10.Cuba and Togo have four characters names. Find the countries that have exactly four characters. 12select name from worldwhere name like &#x27;____&#x27; 11.The capital of Luxembourg is Luxembourg. Show all the countries where the capital is the same as the name of the country Find the country where the name is the capital city. 123select name from worldwhere name=capital 12.The capital of Mexico is Mexico City. Show all the countries where the capital has the country together with the word “City”. Find the country where the capital is the country plus “City”. (capital 이 name +city 인 나라를 출력하라) 123select name from world where capital like concat(name,&#x27; city&#x27;) 13.Find the capital and the name where the capital includes the name of the country. (capital 과 name 을출력하는데 , 캐피탈이 나라의 이름을 포함하는 애들을) 123select capital,namefrom worldwhere capital like &#x27;%&#x27;+name+&#x27;%&#x27; 14.Find the capital and the name where the capital is an extension of name of the country. You should include Mexico City as it is longer than Mexico. You should not include Luxembourg as the capital is the same as the country. (캐피탈과 이름을 출력하는데, 캐피탈이 이름의 연장인 ) 그러나 룩셈부르크 처럼 name과 capital 이 같은 name 은 제외 12345678910select capital,namefrom worldwhere capital like concat(name,&#x27;_%&#x27;)====select capital,name from worldwhere capital like name+&#x27;_%&#x27; 15.For Monaco-Ville the name is Monaco and the extension is -Ville. Show the name and the extension where the capital is an extension of name of the country. capital 에 country name 이 들어가고 추가로 연장문이 들어간 것 들을 name 과 ext 로 나누어서 출력하라 ext 는 연장된것만!! 123select name,replace(capital,name,&#x27;&#x27;) as extfrom worldwhere capital like concat(name,&#x27;_%&#x27;)","categories":[{"name":"Development","slug":"Development","permalink":"https://kimyoungjae777.github.io/categories/Development/"},{"name":"SqlZoo","slug":"Development/SqlZoo","permalink":"https://kimyoungjae777.github.io/categories/Development/SqlZoo/"}],"tags":[{"name":"Development","slug":"Development","permalink":"https://kimyoungjae777.github.io/tags/Development/"},{"name":"SQLZOO","slug":"SQLZOO","permalink":"https://kimyoungjae777.github.io/tags/SQLZOO/"}],"author":"Young Jae Kim"},{"title":"Select Basis","slug":"SelectBasis","date":"2023-01-19T15:00:00.000Z","updated":"2023-04-14T14:29:10.423Z","comments":true,"path":"2023/01/20/SelectBasis/","link":"","permalink":"https://kimyoungjae777.github.io/2023/01/20/SelectBasis/","excerpt":"","text":"SELECT BASIS1.The example uses a WHERE clause to show the population of ‘France’. Note that strings (pieces of text that are data) should be in ‘single quotes’; Modify it to show the population of Germany ANSWERSELECT population FROM worldWHERE name &#x3D; ‘Germany’ Where 을 이용한 조건문 활용 . 2.Checking a list The word IN allows us to check if an item is in a list. The example shows the name and population for the countries ‘Brazil’, ‘Russia’, ‘India’ and ‘China’. Show the name and the population for ‘Sweden’, ‘Norway’ and ‘Denmark’. ANSWERSELECT name, population FROM worldWHERE name IN (‘Sweden’, ‘Norway’, ‘Denmark’); IN 연산자를 통하여 조건문 형성 IN 연산자→ OR 을 여러번 걸어주는 것과 동일 . name 에 스웨덴,노르웨이,덴마크 가 들어간 데이터에 한해서 name과 population 을 조회. 3.Which countries are not too small and not too big? BETWEEN allows range checking (range specified is inclusive of boundary values). The example below shows countries with an area of 250,000-300,000 sq. km. Modify it to show the country and the area for countries with an area between 200,000 and 250,000. Answerselect name,area from worldwhere area between 200000 and 250000 between 을 통해서 area의 데이터를 필터링 해준다 . 200,000 에서 250000 있는 값을 찾는 것.","categories":[{"name":"Development","slug":"Development","permalink":"https://kimyoungjae777.github.io/categories/Development/"},{"name":"SqlZoo","slug":"Development/SqlZoo","permalink":"https://kimyoungjae777.github.io/categories/Development/SqlZoo/"}],"tags":[{"name":"Development","slug":"Development","permalink":"https://kimyoungjae777.github.io/tags/Development/"},{"name":"SQLZOO","slug":"SQLZOO","permalink":"https://kimyoungjae777.github.io/tags/SQLZOO/"}],"author":"Young Jae Kim"},{"title":"관점지향 프로그래밍(AOP)","slug":"관점지향 프로그래밍(AOP,Aspect Oriented Progra 344610b87be6491f867107229614039e","date":"2022-12-31T00:00:00.000Z","updated":"2023-04-14T14:29:10.467Z","comments":true,"path":"2022/12/31/관점지향 프로그래밍(AOP,Aspect Oriented Progra 344610b87be6491f867107229614039e/","link":"","permalink":"https://kimyoungjae777.github.io/2022/12/31/%EA%B4%80%EC%A0%90%EC%A7%80%ED%96%A5%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D(AOP,Aspect%20Oriented%20Progra%20344610b87be6491f867107229614039e/","excerpt":"","text":"관점지향 프로그래밍(AOP,Aspect Oriented Programming)는 무엇이고, 언제 사용할 수 있을까요? AOP는 OOP(Object Oriented Programming, 객체지향 프로그래밍)을 돕는 보조적인 기술로, 관심사의 분리(기능의분리)의 문제를 해결하기 위해 만들어진 프로그래밍 패러다임 입니다. AOP는 기능을 핵심관심사항 과 공통 관심사항 으로 분리시키고 각각을 모듈화 하는 것을 의미합니다 업무 로직을 포함하는 기능을 핵심기능 핵심기능을 도와주는 부가적인 기능을 부가기능 이라고 부른다 OOP를 적용하여도 핵심기능에서 부가기능을 쉽게 분리된 모듈로 작성하기 어려운 문제점을 AOP가 해결해준다. AOP는 부가 기능을 애스펙트(Aspect)로 정의하여, 핵심기능에서 부가기능을 분리함으로써 핵심 기능을 설계하고 구현할 때 객체지향적인 가치를 지킬수 있게 도와주는 개념이다 . [간단한 소스코드로 AOP 살펴보기] 핵심기능을 하는 business logic 과 부가기능을 하는 코드 AAAA,BBBB를 볼 수 있습니다. AAAA,BBBB 가 여기저기서 사용되고 흩어져 있기 때문에 코드변경이 필요한경우 일일이 다 찾아서 바꿔줘야 합니다. AOP는 그렇게 하지 않고 여러곳에서 사용되는 중복된 코드를 떼어내서 분리하고, method a,b,c는 각각 business Logic 만을 갖고 있자. 라는 개념입니다. 여기서 AAAA,BBBB가 AOP에서 말하는 Aspect 입니다. 즉 필수적이지만 어쩔 수 없이 반복적으로 사용되는 코드들을 리펙토링할 수 있도록 해줍니다. 이로인해 여러곳에서 사용될만한 코드들이 한곳에서 유지하고 관리할 수 있는 이점을 갖게 됩니다 AOP를 설명해보아라 AOP는 핵심 비즈니스 로직에 있는 공통 관심사항을 분리하여 각각을 모듈화 하는 것을 의미하며, 공통 모듈인 인증, 로깅, 트랜잭션 처리에 용이합니다 핵심 비즈니스 로직에 부가기능을 하는 모듈이 중복되어 분포되어 있는경우 사용할 수 있습니다 . AOP의 가장 큰 특징이자 장점은 중복 코드제거, 재활용성의 극대화, 변화수용의 용이성이 좋다는 점 입니다. AOP 용어에 대해 알아보자**.** Target 부가기능을 부여할 대상(핵심기능을 담고 있는 모듈) Aspect 부가기능 모듈을 Aspect라고 부른다 (핵심기능에 부가되어 의미를 갖는 모듈) 부가될 기능을 정의한 Advice와 Advice를 어디에 적용할지를 결정하는 PointCut을 함께 갖고 있다. 어플리케이션의 핵심적인 기능에서, 부가적인 기능을 분리해서, Aspect 라는 모듈로 만들어서 설계하고 개발하는 방법. 3.Advice 실질적으로 부가기능을 담은 구현체 타겟 오브젝트에 종속되지 않기 때문에, 부가기능에만 집중할 수 있음 Aspect가 무엇을 언제 할지를 정의 4.PointCut 부가기능이 적용될 대상(Method)을 선정하는 방법 Advice를 적용할 JoinPoint를 선별하는 기능을 정의한 모듈 5.JoinPoint Advice가 적용될 수 있는 위치 Spring에서는 메소드 조인포인트만 제공한다. 타겟 객체가 구현한 모든 메소드는 조인포인트가 된다. 6.proxy Target을 감싸서 Target의 요청을 대신 받아주는 랩핑 오브젝트 클라이언트에서 Target을 호출하게되면, 타겟이 아닌 타겟을 감싸고 있는 proxy가 호출되어, 타겟 메소드 실행 전에 선처리,후처리를 실행한다. 7.Introduction 타겟 클래스에 코드변경없이 신규메소드나 멤버변수를 추가하는 기능 8.Weaving 지정된 객체에 Aspect를 적용해서, 새로운 프록시 객체를 생성하는 과정 Spring AOP는 런타임에서 프록시 객체가 생성된다","categories":[{"name":"Development","slug":"Development","permalink":"https://kimyoungjae777.github.io/categories/Development/"},{"name":"기본개념","slug":"Development/기본개념","permalink":"https://kimyoungjae777.github.io/categories/Development/%EA%B8%B0%EB%B3%B8%EA%B0%9C%EB%85%90/"}],"tags":[{"name":"Development","slug":"Development","permalink":"https://kimyoungjae777.github.io/tags/Development/"},{"name":"기본개념","slug":"기본개념","permalink":"https://kimyoungjae777.github.io/tags/%EA%B8%B0%EB%B3%B8%EA%B0%9C%EB%85%90/"}],"author":"Young Jae Kim"},{"title":"Form 태그로 데이터 주고 받기","slug":"FormTag","date":"2022-12-29T00:00:00.000Z","updated":"2023-04-14T14:29:10.413Z","comments":true,"path":"2022/12/29/FormTag/","link":"","permalink":"https://kimyoungjae777.github.io/2022/12/29/FormTag/","excerpt":"","text":"Form 태그로 데이터 주고 받기🚩 1. Form html 을 form 태그로 꾸며준다 2. form 의 name을 Dto 에 만들어준다 3. action 을 통해 form 태그와 controller 를 연결해주고 데이터를 받아온다. Form 태그 **name:**form 태그에 name 에 이름을 정해주고 이 이름과 , DTO의 이름을 맞추어준다 action: 어떤 컨트롤러와 연결해줄지 정해준다 Controller GetMapping 으로 일반 페이지를 조회시켜주고 PostMapping 으로 데이터를 전송하였을떄 받아주는 역할을 한다. DTO 에 있는것을 가져와서 출력. DTO form 의 name 과 맞추어 주고 생성자로 name 과 매칭시켜 DTO에 저장시켜준다. 그리고 그것을 출력할 수 있게 to string 을 만들어준다.","categories":[{"name":"Development","slug":"Development","permalink":"https://kimyoungjae777.github.io/categories/Development/"},{"name":"기본개념","slug":"Development/기본개념","permalink":"https://kimyoungjae777.github.io/categories/Development/%EA%B8%B0%EB%B3%B8%EA%B0%9C%EB%85%90/"}],"tags":[{"name":"Development","slug":"Development","permalink":"https://kimyoungjae777.github.io/tags/Development/"},{"name":"기본개념","slug":"기본개념","permalink":"https://kimyoungjae777.github.io/tags/%EA%B8%B0%EB%B3%B8%EA%B0%9C%EB%85%90/"}],"author":"Young Jae Kim"},{"title":"RequestBody vs RequestParam","slug":"RequestBody","date":"2022-12-28T00:00:00.000Z","updated":"2023-04-14T14:29:10.420Z","comments":true,"path":"2022/12/28/RequestBody/","link":"","permalink":"https://kimyoungjae777.github.io/2022/12/28/RequestBody/","excerpt":"","text":"RequestBody,RequestParam,ModelAttribute 의 차이컨트롤러에서 데이터를 인자에 할당하는 대표적인 방법으로는 @RequestBody 와 @RequestParam 이 있다. form 태그로 데이터를 전달먼저, 기본적인 형태인 태그를 통해서 데이터를 전송해보자. 아래와 같이 데이터를 전송하여 컨트롤러에서 @RequestBody 를 이용하여 데이터를 받아보겠다. @RequestBody 클라이언트가 전송하는 JSON 형태의 Http Body 내용을 MessageConverter 를 통해 Java Object로 변환시켜주는 역할을 합니다 . 값을 주입하지 않고 값을 변환 시키므로, 변수들의 생성자, Getter,Setter가 없어도 정상적으로 할당된다. ** 우리가 입력한 ‘jun’ 이라는 이름과 ‘13’ 이라는 나이가 잘 전달이 되었지만 단지 ‘name&#x3D;jun&amp;age&#x3D;13’ 이라는 string 으로 전달되어 전달된 데이터를 사용하기엔 불편함이 있다. 그렇다면 이번엔 @RequestParam 으로 받아보자 @RequestParam 1개의 HTTP 요청 파라미터를 받기 위해 사용한다. @RequestParam 필수 여부가 true 이기 때문에 , 기본적으로 반드시 해당 파라미터가 전송되어야 한다. 전송되지 않으면 400 error를 유발할 수 있으며, 반드시 필요한 변수가 아니라면 required&#x3D;false로 설정해줘야 한다. ** @RequestBody 로 데이터를 받을때는 메서드의 변수명이 상관이 없었지만, @RequestParam 으로 데이터를 받을때는 데이터를 저장하는 이름으로 메서드의 변수명을 설정해주어야 한다 결과적으로 jun 이라는 이름이 잘 전달이 되었고, 이번엔 name 이라는 변수에 할당이 되어 사용하기에도 용이하다.","categories":[{"name":"Development","slug":"Development","permalink":"https://kimyoungjae777.github.io/categories/Development/"},{"name":"기본개념","slug":"Development/기본개념","permalink":"https://kimyoungjae777.github.io/categories/Development/%EA%B8%B0%EB%B3%B8%EA%B0%9C%EB%85%90/"}],"tags":[{"name":"Development","slug":"Development","permalink":"https://kimyoungjae777.github.io/tags/Development/"},{"name":"기본개념","slug":"기본개념","permalink":"https://kimyoungjae777.github.io/tags/%EA%B8%B0%EB%B3%B8%EA%B0%9C%EB%85%90/"}],"author":"Young Jae Kim"},{"title":"Spring Boot 와 Spring Framework 의 차이","slug":"Spring Boot 와 Spring Framework 의 차이 eef326fc7e2e43f78491b5fdd815bb0a","date":"2022-12-28T00:00:00.000Z","updated":"2023-04-14T14:29:10.426Z","comments":true,"path":"2022/12/28/Spring Boot 와 Spring Framework 의 차이 eef326fc7e2e43f78491b5fdd815bb0a/","link":"","permalink":"https://kimyoungjae777.github.io/2022/12/28/Spring%20Boot%20%EC%99%80%20Spring%20Framework%20%EC%9D%98%20%EC%B0%A8%EC%9D%B4%20eef326fc7e2e43f78491b5fdd815bb0a/","excerpt":"","text":"Spring Boot 와 Spring Framework 의 차이 가자 큰 차이점은 Auto Configuration 의 차이인 것 같습니다. Spring 은 프로젝트 초기에 다양한 환경설정을 해야 하지만, Spring Boot는 설정의 많은 부분을 자동화하여 사용자가 편하게 스프링을 활용할 수 있도록 돕습니다. Spring Boot Starter Dependency 만 추가해주면 설정은 끝나고, 내장된 톰캣을 제공해 서버를 바로 실행할 수 있습니다.","categories":[{"name":"Development","slug":"Development","permalink":"https://kimyoungjae777.github.io/categories/Development/"},{"name":"기본개념","slug":"Development/기본개념","permalink":"https://kimyoungjae777.github.io/categories/Development/%EA%B8%B0%EB%B3%B8%EA%B0%9C%EB%85%90/"}],"tags":[{"name":"Development","slug":"Development","permalink":"https://kimyoungjae777.github.io/tags/Development/"},{"name":"기본개념","slug":"기본개념","permalink":"https://kimyoungjae777.github.io/tags/%EA%B8%B0%EB%B3%B8%EA%B0%9C%EB%85%90/"}],"author":"Young Jae Kim"},{"title":"Spring Mvc 란","slug":"SpringMvc","date":"2022-12-28T00:00:00.000Z","updated":"2023-04-14T14:29:10.429Z","comments":true,"path":"2022/12/28/SpringMvc/","link":"","permalink":"https://kimyoungjae777.github.io/2022/12/28/SpringMvc/","excerpt":"","text":"Spring MVC 에 대해 설명해주세요 MVC는 Model,View,Controller의 약자이며, 각 레이어간 기능을 구분하는데 중점을 둔 디자인 패턴입니다. Model은 데이터관리 및 비즈니스 로직을 처리하는 부분이며,(DAO,DTO,Service 등) View는 비즈니스 로직의 처리 결과를 통해 유저 인터페이스가 표현되는 구간입니다.(html,jsp,thymeleaf,mustache 등 화면을 구성하기도 하고, Rest API로 서버가 구현된다면 JSON 응답으로 구성되기도 한다) Controller는 사용자의 요청을 처리하고 Model 과 View를 중개하는 역할을 합니다. model 과 view 는 서로 연결되어 있지않기 떄문에 Controller 가 사이에서 통신매체가 되어줍니다. MVC 패턴의 흐름 DispatcherServeket: 클라이언트에게 요청을 받아 응답까지의 MVC 처리과정을 통제한다. HandlerMapping:클라이언트의 요청 URL을 어떤 Controller가 처리할지 결정한다. HandlerAdapter:HandlerMapping에서 결정된 핸들러 정보로 해당 메소드를 직접 호출해주는 역할을한다. ViewResolver:Controller의 처리 결과(데이터)를 생성할 view 를 결정한다. 클라이언트는 URL을 통해 요청을 전송한다. 디스패치 서블릿은 핸들러 매핑을 통해 해당 요청이 어느 컨트롤러에게 온 요청인지 찾는다. 디스패치 서블릿은 핸들러 어댑터에게 요청의 전달을 맡긴다. 핸들러 어댑터는 해당 컨트롤러에 요청을 전달한다. 컨트롤러는 비즈니스 로직을 처리한 후에 반환할 뷰를 찾는다. 디스패치 서블릿은 뷰 리졸버를 통해 반환할 뷰를 찾는다. 디스패치 서블릿은 컨트롤러에서 뷰에 전달할 데이터를 추가한다. 데이터는 추가된 뷰를 변환한다.","categories":[{"name":"Development","slug":"Development","permalink":"https://kimyoungjae777.github.io/categories/Development/"},{"name":"기본개념","slug":"Development/기본개념","permalink":"https://kimyoungjae777.github.io/categories/Development/%EA%B8%B0%EB%B3%B8%EA%B0%9C%EB%85%90/"}],"tags":[{"name":"Development","slug":"Development","permalink":"https://kimyoungjae777.github.io/tags/Development/"},{"name":"기본개념","slug":"기본개념","permalink":"https://kimyoungjae777.github.io/tags/%EA%B8%B0%EB%B3%B8%EA%B0%9C%EB%85%90/"}],"author":"Young Jae Kim"},{"title":"제어의 역전 이란","slug":"제어의역전","date":"2022-12-28T00:00:00.000Z","updated":"2023-04-14T14:29:10.476Z","comments":true,"path":"2022/12/28/제어의역전/","link":"","permalink":"https://kimyoungjae777.github.io/2022/12/28/%EC%A0%9C%EC%96%B4%EC%9D%98%EC%97%AD%EC%A0%84/","excerpt":"","text":"제어의 역전(IOC,Inversion of Control) 제어의 역전(Ioc) 란 모든 객체에 대한 (생성,라이프싸이클 등) 제어권을 개발자가 아닌 IOC 컨테이너에게 넘긴 것을 말합니다. 스프링에서는 IOC 컨테이너에 객체들을 생성하면 객체끼리 의존성을 주입 (DI,Dependency Injectioon) 하는 역할을 하고, 컨테이너에 등록한 객체들을 빈 이라고합니다","categories":[{"name":"Development","slug":"Development","permalink":"https://kimyoungjae777.github.io/categories/Development/"},{"name":"기본개념","slug":"Development/기본개념","permalink":"https://kimyoungjae777.github.io/categories/Development/%EA%B8%B0%EB%B3%B8%EA%B0%9C%EB%85%90/"}],"tags":[{"name":"Development","slug":"Development","permalink":"https://kimyoungjae777.github.io/tags/Development/"},{"name":"기본개념","slug":"기본개념","permalink":"https://kimyoungjae777.github.io/tags/%EA%B8%B0%EB%B3%B8%EA%B0%9C%EB%85%90/"}],"author":"Young Jae Kim"},{"title":"SpringFramework 란?","slug":"Spring Framework 란 6d291ec22b0e4e9e815ca21e8c66e1af","date":"2022-12-09T00:00:00.000Z","updated":"2023-04-14T14:29:10.427Z","comments":true,"path":"2022/12/09/Spring Framework 란 6d291ec22b0e4e9e815ca21e8c66e1af/","link":"","permalink":"https://kimyoungjae777.github.io/2022/12/09/Spring%20Framework%20%EB%9E%80%206d291ec22b0e4e9e815ca21e8c66e1af/","excerpt":"","text":"Spring Framework 란? 스링 프레임워크는 자바 개발을 편리하게 해주는 오픈소스 프레임워크 이다. 경량 컨테이너로서 자바 객체를 직접관리 → 각자의 객체 생성, 소멸과 같은 라이프 사이클을 관리하며 스프링으로부터 필요한 객체를 얻어올 수 있다. 제어의 역전(IOC,Inverse Of Control) 이라는 기술을 통해 어플리케이션의 느슨한 결합을 도모한다. → 컨트롤의 제어권이 사용자가 아닌 프레임워크에 있어서 필요에 따라 스프링에서 사용자의 코드를 호출한다. 의존성 주입(DI,Dependency Injection) 을 지원 → 각각의 계층이나 서비스들 간에 의존성이 존재할 경우 프레임워크가 서로 연결시켜 준다. 관점 지향 프로그래밍(AOP,Aspect-Oriented Programming)을 지원 →트랜잭션이나 로깅,보안과 같이 여러 모듈에서 공통적으로 사용하는 기능의 경우 해당기능을 분리하여 관리할 수 있다.","categories":[{"name":"Development","slug":"Development","permalink":"https://kimyoungjae777.github.io/categories/Development/"},{"name":"기본개념","slug":"Development/기본개념","permalink":"https://kimyoungjae777.github.io/categories/Development/%EA%B8%B0%EB%B3%B8%EA%B0%9C%EB%85%90/"}],"tags":[{"name":"Development","slug":"Development","permalink":"https://kimyoungjae777.github.io/tags/Development/"},{"name":"기본개념","slug":"기본개념","permalink":"https://kimyoungjae777.github.io/tags/%EA%B8%B0%EB%B3%B8%EA%B0%9C%EB%85%90/"}],"author":"Young Jae Kim"},{"title":"WAS(Web Application Server)","slug":"WAS(Web Applicatin Server)","date":"2022-12-04T00:00:00.000Z","updated":"2023-04-14T14:29:10.437Z","comments":true,"path":"2022/12/04/WAS(Web Applicatin Server)/","link":"","permalink":"https://kimyoungjae777.github.io/2022/12/04/WAS(Web%20Applicatin%20Server)/","excerpt":"","text":"WAS(Web Applicatin Server) 웹 어플리케이션 서버(WAS)란, 웹 서버와 웹 컨테이너의 기능을 모두 수행하는 프로그램을 말한다. 웹컨테이너 웹 컨테이너는 클라이언트의 요청에 따른 데이터를 데이터베이스에서 전달받아 웹서버로 전달하는 프로그램이다 프로그램 실행환경과 데이터베이스 접속 기능을 제공한다. 여러개의 트랜젝션을 관리한다. 업무 처리를 위한 비즈니스 로직을 수행한다 Web Service 플랫폼의 역할을 수행한다. 이러한 웹 컨테이너는 jsp,php 등 개발언어를 읽고 포털검색 결과와 같은 콘텐츠, 다소 복잡한 웹 응용 프로그램 등을 처리한다. 웹 서버가 한번 다운로드 되면 내용이 변하지 않는, HTML 문서와 같은 정적 콘텐츠를 처리하는 것과 비교된다. 또한 웹 서버 측에서 클라이언트이 요청을 받아 응답을 할 때, 요청에 필요한 데이터를 처리하거나 웹서버에 전달해주는 역할을 한다. 때문에, 데이터베이스 서버와 같이 작업을 수행하는 경우가 많다. 일종의 중간관리자로 웹 서버를 지원하는 역할이라고 보면 되겠다. 이런 소프트웨어를 미들웨어 라고한다. WAS 서버는 원래 이 웹 컨테이너 프로그램을 말하는 것인데, 요즘의 WAS 서버는 웹컨테이너 기능에 웹서버 기능까지 내장하고 있는 경우가 많다. 그러다 보니 WAS 서버는 웹서버+웹 컨테이너를 합친 프로그램을 말하는 의미로 쓰이고 있다. 출처:06. 웹 서버(WEB)란 무엇인가? (tistory.com)","categories":[{"name":"Development","slug":"Development","permalink":"https://kimyoungjae777.github.io/categories/Development/"},{"name":"기본개념","slug":"Development/기본개념","permalink":"https://kimyoungjae777.github.io/categories/Development/%EA%B8%B0%EB%B3%B8%EA%B0%9C%EB%85%90/"}],"tags":[{"name":"Development","slug":"Development","permalink":"https://kimyoungjae777.github.io/tags/Development/"},{"name":"기본개념","slug":"기본개념","permalink":"https://kimyoungjae777.github.io/tags/%EA%B8%B0%EB%B3%B8%EA%B0%9C%EB%85%90/"}],"author":"Young Jae Kim"},{"title":"WAS VS WS","slug":"WAS(WebApplicationServer) vs ws(WebServer) 4ee001da9c2b4b8eaf8d77d1381ccdfa","date":"2022-12-04T00:00:00.000Z","updated":"2023-04-14T14:29:10.439Z","comments":true,"path":"2022/12/04/WAS(WebApplicationServer) vs ws(WebServer) 4ee001da9c2b4b8eaf8d77d1381ccdfa/","link":"","permalink":"https://kimyoungjae777.github.io/2022/12/04/WAS(WebApplicationServer)%20vs%20ws(WebServer)%204ee001da9c2b4b8eaf8d77d1381ccdfa/","excerpt":"","text":"WAS(WebApplicationServer) vs ws(WebServer)WAS 비즈니스 로직을 넣을수 있음(유동적) Tomcat,PHP,ASP,.NET 등 WS(Web Server) 비즈니스 로직을 넣을 수 없음(정적) Nginx,Apache 등","categories":[{"name":"Development","slug":"Development","permalink":"https://kimyoungjae777.github.io/categories/Development/"},{"name":"기본개념","slug":"Development/기본개념","permalink":"https://kimyoungjae777.github.io/categories/Development/%EA%B8%B0%EB%B3%B8%EA%B0%9C%EB%85%90/"}],"tags":[{"name":"Development","slug":"Development","permalink":"https://kimyoungjae777.github.io/tags/Development/"},{"name":"기본개념","slug":"기본개념","permalink":"https://kimyoungjae777.github.io/tags/%EA%B8%B0%EB%B3%B8%EA%B0%9C%EB%85%90/"}],"author":"Young Jae Kim"},{"title":"WS(WebServer)","slug":"WS(WebServer)","date":"2022-12-04T00:00:00.000Z","updated":"2023-04-14T14:29:10.440Z","comments":true,"path":"2022/12/04/WS(WebServer)/","link":"","permalink":"https://kimyoungjae777.github.io/2022/12/04/WS(WebServer)/","excerpt":"","text":"WS(WebServer) 서버 프로그램 클라이언트의 요청에 응답을 보내는 컴퓨터 프로그램을 말한다. 클라이언트가 데이터를 요청하면 데이터를 주는 쪽이라고 생각하면 된다. 이 데이터는 HTML 문서이거나 컴퓨터에 저장된 각종 리소스(자원) 이다. 가장 많이 사용되는 웹서버프로그램은 Apache,Nginx,Microsoft lls 등이다. 이 중, Apache,Nginx는 오픈소스 소프트웨어로, 거의 대부분의 운영체제에 무료로 설치 및 사용을 할 수 있다.","categories":[{"name":"Development","slug":"Development","permalink":"https://kimyoungjae777.github.io/categories/Development/"},{"name":"기본개념","slug":"Development/기본개념","permalink":"https://kimyoungjae777.github.io/categories/Development/%EA%B8%B0%EB%B3%B8%EA%B0%9C%EB%85%90/"}],"tags":[{"name":"Development","slug":"Development","permalink":"https://kimyoungjae777.github.io/tags/Development/"},{"name":"기본개념","slug":"기본개념","permalink":"https://kimyoungjae777.github.io/tags/%EA%B8%B0%EB%B3%B8%EA%B0%9C%EB%85%90/"}],"author":"Young Jae Kim"},{"title":"PostMapping_vs_GetMapping","slug":"getMappingVsPostMapping","date":"2022-12-04T00:00:00.000Z","updated":"2023-04-14T14:29:10.444Z","comments":true,"path":"2022/12/04/getMappingVsPostMapping/","link":"","permalink":"https://kimyoungjae777.github.io/2022/12/04/getMappingVsPostMapping/","excerpt":"","text":"GetMapping,PostMappingGET 방식: 어떠한 정보를 가져와서 조회하기 위해 사용되는 방식 URL에 변수를 포함시켜 요청한다. 데이터를 header를 포함하여 전송한다. url에 데이터가 노출되어 보안에 취약하다. 캐싱이 가능하다. (캐싱:한번 접근후, 똑같은 요청을 할 시 빠르게 접근하기 위해 레지스터에 데이터를 저장시키는것) post 방식: 데이터를 서버로 제출하여 추가 또는 수정하기 위해서 데이터를 전송하는 방식 URL에 변수에 변수를 노출하지 않고 요청을 한다. 데이터를 body에 포함시킨다. url에 데이터가 노출되지 않아서 기본 보안이 설정되어 있다. 전송하는데 길이 제한이 없다 캐싱이 불가능하다","categories":[{"name":"Development","slug":"Development","permalink":"https://kimyoungjae777.github.io/categories/Development/"},{"name":"기본개념","slug":"Development/기본개념","permalink":"https://kimyoungjae777.github.io/categories/Development/%EA%B8%B0%EB%B3%B8%EA%B0%9C%EB%85%90/"}],"tags":[{"name":"Development","slug":"Development","permalink":"https://kimyoungjae777.github.io/tags/Development/"},{"name":"기본개념","slug":"기본개념","permalink":"https://kimyoungjae777.github.io/tags/%EA%B8%B0%EB%B3%B8%EA%B0%9C%EB%85%90/"}],"author":"Young Jae Kim"},{"title":"Hikari CP란?","slug":"hikariCP","date":"2022-12-01T00:00:00.000Z","updated":"2023-04-14T14:29:10.447Z","comments":true,"path":"2022/12/01/hikariCP/","link":"","permalink":"https://kimyoungjae777.github.io/2022/12/01/hikariCP/","excerpt":"","text":"Hikari CP HikariCP는 Database와의 커넥션 풀을 관리한다. 관리해주어야하는 이유는 JDBC커넥션을 맺는 과정은 상당히 복잡하고 자원을 많이 소모하는 작업이기 때문에 관리를 해야 성능적으로 좋기 때문이다. 만약 요청이 들어올 때 Thread가 Database와의 커넥션을 맺는다면 데이터베이스 뿐만 아니라 앱서버 입장에서도 굉장히 부하가 심하게 발생 할 것이다. 그런데 HikariCP는 미리 정해놓은 만큼에 커넥션은 pool에 담아 놓는다. 요청이 들어오면 Thread가 커넥션을 요청하고, Hikari는 Pool내에 있는 커넥션을 연결해준다. ⇒ 결론: 자바와 데이터베이스를 연결시키는 일은 부하가 많이되는 작업이기 때문에 , 미리정해놓은 커넥션을 Pool에 담아 놓고 요청이 들어오면 Thread가 커넥션을 요청하고, Hikari pool 내에 있는 커넥션을 연결해준다. Connection Pool (커넥션 풀) 데이터 연동과정에서 일반적인 연동과정은 웹 어플리케이션이 필요할 때마다 데이터베이스에 연결하여 작업하는 방식이다. 그런데 이런 식으로 필요할 때마다 연동해서 작업할 경우 데이터베이스 연결에 시간이 많이 걸린다는 문제가 있다. 이 문제를 해결하기 위해 현재는 웹 어플리케이션이 실행됨과 동시에 연동할 데이터베이스와의 연결을 미리 설정해 두고, 필요할 때마다 미리 연결해 놓은 상태를 이용해 빠르게 데이터베이스와 연동하여 작업을 한다. 이 작업을 Connection Pool 이라고 한다. 출처:Hikari Connection Pool이란? (tistory.com)","categories":[{"name":"Development","slug":"Development","permalink":"https://kimyoungjae777.github.io/categories/Development/"},{"name":"기본개념","slug":"Development/기본개념","permalink":"https://kimyoungjae777.github.io/categories/Development/%EA%B8%B0%EB%B3%B8%EA%B0%9C%EB%85%90/"}],"tags":[{"name":"Development","slug":"Development","permalink":"https://kimyoungjae777.github.io/tags/Development/"},{"name":"기본개념","slug":"기본개념","permalink":"https://kimyoungjae777.github.io/tags/%EA%B8%B0%EB%B3%B8%EA%B0%9C%EB%85%90/"}],"author":"Young Jae Kim"},{"title":"웹페이지 만들기.4(Verdeterr)게시글삭제구현","slug":"게시글삭제구현","date":"2022-11-19T00:00:00.000Z","updated":"2023-04-14T14:29:10.466Z","comments":true,"path":"2022/11/19/게시글삭제구현/","link":"","permalink":"https://kimyoungjae777.github.io/2022/11/19/%EA%B2%8C%EC%8B%9C%EA%B8%80%EC%82%AD%EC%A0%9C%EA%B5%AC%ED%98%84/","excerpt":"","text":"게시글 삭제 구현1.컨트롤러(Controller)BoardController 클래스에서 게시글 삭제를 처리하는 메서드를 작성한다. 12345678910111213141516171819202122@PostMapping(value = &quot;/board/delete&quot;) public String deleteBoard(@RequestParam String type, @RequestParam(value = &quot;idx&quot;, required = false) Long idx, Model model) &#123; System.out.println(&quot;여기로 들어오나요?&quot;); if (idx == null) &#123; return showMessageWithRedirect(&quot;올바르지 않은 접근입니다.&quot;, &quot;/board/list&quot;, Method.GET, null, model); &#125; try &#123; boolean isDeleted = boardService.deleteBoard(idx); if (isDeleted == false) &#123; return showMessageWithRedirect(&quot;게시글 삭제에 실패하였습니다.&quot;, &quot;/board/list&quot;, Method.GET, null, model); &#125; &#125; catch (DataAccessException e) &#123; return showMessageWithRedirect(&quot;데이터베이스 처리 과정에 문제가 발생하였습니다.&quot;, &quot;/board/list&quot;, Method.GET, null, model); &#125; catch (Exception e) &#123; return showMessageWithRedirect(&quot;시스템에 문제가 발생하였습니다.&quot;, &quot;/board/list&quot;, Method.GET, null, model); &#125; String url = &quot;/board/list?type=&quot; + type; return showMessageWithRedirect(&quot;게시글 삭제가 완료되었습니다.&quot;, url, Method.GET, null, model); &#125; @RequestParam: 게시글 삭제에 필요한 게시글 번호(idx)를 파라미터로 전달받는다. 전체로직: 로직이 시작되는 if문에서 idx가 파라미터로 전달되지 않았다면 사용자에게 적절한 메세지를 전달하고 게시글 리스트로 리다이렉트 한다. 정상적인 경우에는 deleteBoard 메서드의 인자로 idx를 전달하고 게시글을 삭제한다. deleteBoard 메서드에서 문제가 발생하면 catch 영역에서 printStackTrace 메서드로 오류를 축척한다. 보통은, 시스템에서 예외가 발생하면 예외 로그파일로 기럭하거나 작업을 중단하지만, 여기에서는 예외 메세지를 사용자에게 전달하고 게시글 리스트로 리다이렉트 한다. 2.화면(view)게시글 상세페이지의 삭제하기 버튼을 클릭하면 게시글 삭제 이벤트가 발생한다. 이전 포스팅의 view.html 에서 삭제하기 버튼에 이벤트를 지정해 두었기 때문에 자바스크립트 영역만 처리한다. 123456789101112131415161718192021&lt;th:block layout:fragment=&quot;script&quot;&gt; &lt;script th:inline=&quot;javascript&quot;&gt; /*&lt;![CDATA[*/ function deleteBoard(idx) &#123; console.log(&quot;deleteBoard 호출됨&quot;); if (confirm(idx + &quot;번 게시글을 삭제할까요?&quot;)) &#123; var uri = /*[[ @&#123;/board/delete&#125; ]]*/null; var type = /*[[ $&#123;type&#125; ]]*/null; var html = &quot;&quot; html += &#x27;&lt;form name=&quot;dataForm&quot; action=&quot;&#x27; + uri + &#x27;&quot; method=&quot;post&quot;&gt;&#x27;; html += &#x27;&lt;input type=&quot;hidden&quot; name=&quot;idx&quot; value=&quot;&#x27; + idx + &#x27;&quot; /&gt;&#x27;; html += &#x27;&lt;input type=&quot;hidden&quot; name=&quot;type&quot; value=&quot;&#x27; + type + &#x27;&quot; /&gt;&#x27;; html += &#x27;&lt;/form&gt;&#x27;; $(&quot;body&quot;).append(html); document.dataForm.submit(); &#125; &#125; /*[- end of function -]*/ /*]]&gt;*/ layout:fragment&#x3D;”script” : 게시글 등록과 마찬가지로 페이지마다 로직이 다르기 때문에 fragment를 사용한다. th:inline&#x3D;”javascript” : script 태그에 th:inline 속성을 javascript로 선언해야 자바스크립트를 사용할 수 있다. “&lt;![CDATA[]]&gt; : thymeleaf는 ‘&lt;’, ‘&gt;’를 엄격하게 검사하기 때문에 자바스크립트는 반드시 CDATA로 묶어야 한다. CDATA는 특수문자를 전부 문자열로 치환할 때 사용한다. deleteBoard 함수 : 삭제하기 버튼의 deleteBoard 함수의 인자로 게시글 번호를 저장했기 때문에 함수의 파라미터로 게시글 번호를 전달받는다. confirm : 자바스크립트의 Alert 창과 유사하다. Confirm(선택) 함수를 이용하여 다시 한 번 게시글의 삭제 여부를 확인하며, 확인 버튼은 True, 취소 버튼은 False를 리턴한다. uri : BoardController에 선언한 게시글 삭제 메서드와 매핑된 URI를 의미한다. html : dataForm이라는 이름의 폼 안에 함수의 파라미터로 전달받은 idx를 hidden 타입으로 추가한다. 게시글 삭제 이벤트가 발생할 때만 element를 추가하기 위해 동적으로 폼을 생성하는 방식을 택한다. 삭제를 완료하고 나면, 테이블을 조회하였을때 , DeleteYn 에 1로 표시된것을 볼 수 있다. 참고 블로그:스프링 부트 게시판 만들기 7 - 게시글 삭제 구현 : 네이버 블로그 (naver.com)","categories":[{"name":"Development","slug":"Development","permalink":"https://kimyoungjae777.github.io/categories/Development/"},{"name":"Verdeterr(웹프로젝트)","slug":"Development/Verdeterr-웹프로젝트","permalink":"https://kimyoungjae777.github.io/categories/Development/Verdeterr-%EC%9B%B9%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/"}],"tags":[{"name":"Development","slug":"Development","permalink":"https://kimyoungjae777.github.io/tags/Development/"},{"name":"Verdeterr(웹프로젝트)","slug":"Verdeterr-웹프로젝트","permalink":"https://kimyoungjae777.github.io/tags/Verdeterr-%EC%9B%B9%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/"}],"author":"Young Jae Kim"},{"title":"컨트롤러에서 뷰로 데이터를 넘기는 원리","slug":"Controller 에서 view 로 데이터 넘겨받기 ea169cafd49d496db069ff008484d54d","date":"2022-11-17T00:00:00.000Z","updated":"2023-04-14T14:29:10.411Z","comments":true,"path":"2022/11/17/Controller 에서 view 로 데이터 넘겨받기 ea169cafd49d496db069ff008484d54d/","link":"","permalink":"https://kimyoungjae777.github.io/2022/11/17/Controller%20%EC%97%90%EC%84%9C%20view%20%EB%A1%9C%20%EB%8D%B0%EC%9D%B4%ED%84%B0%20%EB%84%98%EA%B2%A8%EB%B0%9B%EA%B8%B0%20ea169cafd49d496db069ff008484d54d/","excerpt":"","text":"Controller 에서 view 로 데이터 넘겨받기화면 처리( controller 에서 view 단으로 넘어가는 원리) addAttribute 메서드 : 해당 메서드를 이용하여, 화면으로 데이터를 전달할 수 있다. 메서드의 인자로는 이름(String name), 값(Object value)을 전달한다. 웬만해서는 이름과 값을 동일하게 지정하는 것이 좋다. HTML에서는 ${} 표현식을 이용하여 전달받은 데이터에 접근할 수 있다. thymeleaf를 이용하여 전달받은 데이터 값을 화면에 출력해보자 test.html 코드를 다음과 같이 변경한다. ${} 안에 이름을 쓰면, 값이 출력되어진다. 8080 포트: WAS(WebApplicationServer) 에 해당하는 톰캣의 기본 포트이다. 스프링부트에서 WAS는 기본적으로 내장되어 있는 톰캣을 사용하며, application.properties 에서 server.port 속성을 이용해서 원하는 포트로 지정 가능하다. &#x2F;board&#x2F;test: openBoardWrite 메서드와 매핑된 URL을 의미한다. 만약 매핑되지 않은 URL을 호출하는 경우에는 404 에러가 발생한다. 404에러는 “서버에서 사용자의 요청 URL을 찾을수 없음” 을 의미한다. HTTP 상태코드(Status code) 를 확인해보면 종류별로 나와있다.","categories":[{"name":"Development","slug":"Development","permalink":"https://kimyoungjae777.github.io/categories/Development/"},{"name":"기본개념","slug":"Development/기본개념","permalink":"https://kimyoungjae777.github.io/categories/Development/%EA%B8%B0%EB%B3%B8%EA%B0%9C%EB%85%90/"}],"tags":[{"name":"Development","slug":"Development","permalink":"https://kimyoungjae777.github.io/tags/Development/"},{"name":"기본개념","slug":"기본개념","permalink":"https://kimyoungjae777.github.io/tags/%EA%B8%B0%EB%B3%B8%EA%B0%9C%EB%85%90/"}],"author":"Young Jae Kim"},{"title":"Thymeleaf 자주 사용하는 문법","slug":"Thymeleaf기본문법","date":"2022-11-17T00:00:00.000Z","updated":"2023-04-14T14:29:10.434Z","comments":true,"path":"2022/11/17/Thymeleaf기본문법/","link":"","permalink":"https://kimyoungjae777.github.io/2022/11/17/Thymeleaf%EA%B8%B0%EB%B3%B8%EB%AC%B8%EB%B2%95/","excerpt":"","text":"Thymeleaf 자주 사용하는 문법th:text 화면에 값을 출력할 때 사용 1&lt;span th:text=&quot;$&#123;nickname&#125;&quot;&gt;&lt;/span&gt; th:object form submit을 할 때, form의 데이터가 th:object에 설정해준 객체로 받아진다. th:field 각각 필드들을 매핑을 해주는 역할을 한다. 설정해 준 값으로, th:obecjt에 설정해 준 객에의 내부와 매핑해준다. 123456&lt;form th:action=&quot;@&#123;/sign-up&#125;&quot; th:object=&quot;$&#123;signUpForm&#125;&quot; method=&quot;post&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;nickname&quot;&gt;닉네임&lt;/label&gt; &lt;input id=&quot;nickname&quot; type=&quot;text&quot; th:field=&quot;*&#123;nickname&#125;&quot; class=&quot;form-control&quot;&gt; &lt;/div&gt; &lt;/form&gt; 안의 데이터를 sign-up controller 로 보낼거고 , signUpForm 객체의 nickname으로 매핑시켜준다. th:fragment header,footer,navigation bar 같이 모든 페이지에 보여져야하는 항목인 경우 따로 분리해서 관리한다.","categories":[{"name":"Development","slug":"Development","permalink":"https://kimyoungjae777.github.io/categories/Development/"},{"name":"기본개념","slug":"Development/기본개념","permalink":"https://kimyoungjae777.github.io/categories/Development/%EA%B8%B0%EB%B3%B8%EA%B0%9C%EB%85%90/"}],"tags":[{"name":"Development","slug":"Development","permalink":"https://kimyoungjae777.github.io/tags/Development/"},{"name":"기본개념","slug":"기본개념","permalink":"https://kimyoungjae777.github.io/tags/%EA%B8%B0%EB%B3%B8%EA%B0%9C%EB%85%90/"}],"author":"Young Jae Kim"},{"title":"웹페이지 만들기.3(Verdeterr)게시글 리스트구현","slug":"게시글리스트구현","date":"2022-11-17T00:00:00.000Z","updated":"2023-04-14T14:29:10.464Z","comments":true,"path":"2022/11/17/게시글리스트구현/","link":"","permalink":"https://kimyoungjae777.github.io/2022/11/17/%EA%B2%8C%EC%8B%9C%EA%B8%80%EB%A6%AC%EC%8A%A4%ED%8A%B8%EA%B5%AC%ED%98%84/","excerpt":"","text":"게시글 리스트 구현컨트롤러 @GetMapping : Get 방식의 HTTP 요청 메서드를 의미한다 boardList: BoardService 에서 호출한 getBoardList 메서드의 실행결과를 boardList에 담아 뷰로 전달한다 getBoardList 에서의 params 파라미터는 나중에 페이징처리 할때 필요한 것이다. Model : 컨트롤러에서 화면으로 데이터를 전달하는데 사용되는 인터페이스다. return 문: 컨트롤러의 리턴 타입이 String이면 리턴 문에 지정된 경로의 HTML이 화면에 출력된다. 해당 메서드의 “board&#x2F;list” 는 src&#x2F;main&#x2F;resources 디렉터리의 templates&#x2F;board&#x2F;list.html 을 의미한다 화면(view) &lt;th:block layout fragment&#x3D;”search”&gt; : search 검색창을 정의하는 부분으로 fragments&#x2F;common 에 있는 search 로 대체한다. layout:fragment&#x3D;”content” : 게시글 리스트 페이지의 실제 Content가 들어가는 영역이다. 게시글 리스트는 보통 테이블 형태로 처리된다. th:if, th:unless 속성: th:if 는 if 문과 동일하고, th:unless 는 else 문과 동일하다. th:unless는 일반적인 언어의 else 문과는 다르게 th:if에 들어가는 조건과 동일한 조건을 지정해야한다 . th:if의 조건이 성립되면 게시글 리스트가 출력되고, th:unless의 조건이 성립되면 “조회된 결과가 없습니다” 가 출력된다. #lists.isEmpty 함수 : 해당 함수는 인자로 지정한 데이터가 비어있는지 확인하는데 사용된다. 컨트롤러의 openBoardList 메서드에서 전달받은 게시글 데이터 boardList가 비어있는지 않은지를 확인한다. isEmpty 함수는 데이터가 비어있으면 true를 리턴한다. 인자의 공백은 가독성을 높이기 위해 넣은것이고 붙여써도 무관하다. th:each 속성: 자브의 forEach와 유사한 기능을 한다. 여기서는 row라는 이름으로 boardList를 순환해서 데이터를 출력한다. td scope&#x3D;”row” th:text&#x3D;”$#strings.equals(row.noticeYn,’Y’) ? ‘공지’:row.idx”&#x2F;td : # strings.equals 함수를 사용하여 공지여부가 ‘Y’로 등록된 글이라면 “공지”를 출력하고, ‘N’ 으로 등록된 글이라면 게시글 번호를 출력한다. equals 함수는 문자열을 비교하는데 사용한다. td class&#x3D;”test-left”&gt; &lt;a th:href&#x3D;”@{&#x2F;board&#x2F;view(idx&#x3D;$row.idx)}” th:text&#x3D;”${row.title}”&gt;: 게시글 제목을 클릭하면 특정 게시글의 상세페이지를 의미하는 “&#x2F;board&#x2F;view URL을 호출한다. 보통 href 속성에 파리미터를 포함시킬때 첫번째 파라미터는 ? 로, 두번째 파라미터는 &amp;으로 연결하는데, thymeleaf에서는 URL 뒤에 괄호를 열어서 파라미터를 포함시킨다. 일반적인 GET 파라미터 추가방식 &#x2F;board&#x2F;view&#x2F;?idx&#x3D;${idx}&amp;page&#x3D;${page} thymeleaf의 GET 파라미터 추가 방식 &#x2F;board&#x2F;vew(idx&#x3D;${idx},page&#x3D;${page} : 작성자 텍스트 형식으로 출력한다. : BoardDTO 클래스에서 시간관련 xxxTime 인스턴스 변수는 temporals.format 함수를 사용하여 포맷한다. : 특정 게시글의 조회수를 텍스트 형식으로 출력한다. Write 버튼: “board&#x2F;write URL을 호출하여 신규 글 작성페이지로 이동한다. layout:fragment&#x3D;”paging”: 리스트에서 특정 페이지로 이동할 수 있는 페이징 영역이다. &lt;그리하면 이렇게, list.html 이 이러한 형식으로 나온다.&gt;","categories":[{"name":"Development","slug":"Development","permalink":"https://kimyoungjae777.github.io/categories/Development/"},{"name":"Verdeterr(웹프로젝트)","slug":"Development/Verdeterr-웹프로젝트","permalink":"https://kimyoungjae777.github.io/categories/Development/Verdeterr-%EC%9B%B9%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/"}],"tags":[{"name":"Development","slug":"Development","permalink":"https://kimyoungjae777.github.io/tags/Development/"},{"name":"Verdeterr(웹프로젝트)","slug":"Verdeterr-웹프로젝트","permalink":"https://kimyoungjae777.github.io/tags/Verdeterr-%EC%9B%B9%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/"}],"author":"Young Jae Kim"},{"title":"웹페이지 만들기.2(Verdeterr)-게시글 등록구현","slug":"게시글등록구현","date":"2022-11-17T00:00:00.000Z","updated":"2023-04-14T14:29:10.462Z","comments":true,"path":"2022/11/17/게시글등록구현/","link":"","permalink":"https://kimyoungjae777.github.io/2022/11/17/%EA%B2%8C%EC%8B%9C%EA%B8%80%EB%93%B1%EB%A1%9D%EA%B5%AC%ED%98%84/","excerpt":"","text":"게시글 등록 구현하기지난 포스팅에서는 게시판의 CRUD 처리를 했다. 이번에는 게시글 등록을 구현해보도록 하겠다. 먼저, 비즈니스 로직을 담당하는 서비스를 처리해보도록 하자. 1.서비스 처리 이전에 Mapper 영역 처리를 완료했으므로 서비스 영역을 진행한다. 먼저, com.board.service 패키지에 BoardService 인터페이스를 생성하고 다음의 코드를 작성한다. ![Untitled](images&#x2F;registerBoard&#x2F; 실제 자바에서 돌아갈 함수들을 인터페이스로 정의해준다. 이는 서비스를 인터페이스로 지정해준것이고, 실제 서비스가 돌아갈 함수를 만들어줄 클래스인 BoardServiceImpl 을 만들어준다. **@SERVICE :**BoardMapper 인터페이스의 @Mapper와 유사하며, 해당 클래스가 비즈니스 로직을 담당하는 서비스 클래스임을 의미한다 implements: BoardService 인터페이스에 정의된 메서드 구현을 위해 BoardService 를 상속받는다. BoardMapper: @Autowired를 이용하여 BoardMapper 인터페이스 Bean을 주입한다. registerBoard: 게시글 생성 함수로서 , 수정과 등록을 동시에 해준다. 만약에 파라미터로 게시글 번호(idx) 가 들어와 주었다면, updateBoard 즉, 수정 함수를 실행시켜주고 만약 파라미터로 아무것도 들어오지 않았다면, insertBoard 함수를 실행시켜 주면서, 게시글 등록 함수를 실행시켜 준다 . 또한 queryResult 로 함수의 실행결과를 return 해준다. getBoardList: List 형식으로 리턴을 받고, NPE 방지를 위해, emptyList() 함수를 사용하여준다, 그리고 boardTotalCount가 &gt;0 일때는 그곳에 담겨져 있는 selectBoardList 함수를 실행시켜, 가져와서 boardList 방식으로 리턴을 받아준다. 2. 컨트롤러 처리사용자가 보는 화면인 User Interface를 담당하는 컨트롤러에 대해 알아보자. com.board.controller 패키지에 BoardController 클래스를 생성하고 다음의 코드를 입력한다 @Controller: 해당 클래스가 사용자의 요청과 응답을 처리하는 UI 담당 컨트롤러 클래스임을 의미한다. @GetMapping:스프링4.3버젼 부터는 @GetMapping ,@PostMapping 등의 Annotation을 추가함으로써 요청 메서드의 타입별 매핑을 처리할 수 있다. 기존의 URI 매핑 - @RequestMapping(value&#x3D;”…”, method &#x3D; RequestMethod.xxx) 새로운 URI 매핑 - @xxxMapping(value&#x3D;”…”) 리턴타입 : controller 메서드의 리턴타입은 void,String,ModelAndView,Map,List 등 여러가지 리턴타입을 지정할 수 있다. 대표적으로 String,ModelAndView는 사용자에게 보여줄 화면 (HTML 경로)를 리턴문에 지정하여 처리해준다. 최근에는 String을 많이 선호한다. 리턴문에 지정하여 처리해준다. 최근에는 String을 많이 선호한다. 리턴문에 지정된 HTML 경로의 끝에는 확장자(”.html”)가 자동으로 연결되므로 확장자를 생략할 수 있다. Model: 메서드의 파리미터로 지정된 Model 인터페이스는 데이터를 뷰로 전달하는 역할을 한다. 3.화면 처리( controller 에서 view 단으로 넘어가는 원리) value 부분은 우리가 주소를 치고 들어가는 경로를 의미 컨트롤러 처리를 마무리하면 메서드의 리턴타입으로 지정된 경로에 화면(HTML)을 생성해야 한다. src&#x2F;main&#x2F;resource 디렉터리의 templates 패키지에 board 패키지를 추가하고 board 패키지에 test.html을 추가한후 다음 코드를 입력한다. 이제는 데이터를 넘겨 받아보자. addAttribute 메서드 : 해당 메서드를 이용하여, 화면으로 데이터를 전달할 수 있다. 메서드의 인자로는 이름(String name), 값(Object value)을 전달한다. 웬만해서는 이름과 값을 동일하게 지정하는 것이 좋다. HTML에서는 ${} 표현식을 이용하여 전달받은 데이터에 접근할 수 있다. thymeleaf를 이용하여 전달받은 데이터 값을 화면에 출력해보자 test.html 코드를 다음과 같이 변경한다. ${} 안에 이름을 쓰면, 값이 출력되어진다. 8080 포트: WAS(WebApplicationServer) 에 해당하는 톰캣의 기본 포트이다. 스프링부트에서 WAS는 기본적으로 내장되어 있는 톰캣을 사용하며, application.properties 에서 server.port 속성을 이용해서 원하는 포트로 지정 가능하다. &#x2F;board&#x2F;test: openBoardWrite 메서드와 매핑된 URL을 의미한다. 만약 매핑되지 않은 URL을 호출하는 경우에는 404 에러가 발생한다. 404에러는 “서버에서 사용자의 요청 URL을 찾을수 없음” 을 의미한다. HTTP 상태코드(Status code) 를 확인해보면 종류별로 나와있다. 부트스트랩 적용 부트스트랩은 UI를 쉽고 빠르게 세련되게 만들어 주는 HTML,CSS,JS프레임워크이다. 부트스트랩 파일을 src&#x2F;main&#x2F;resources 디렉터리에 추가한다. 다음으로 화면에서 공통으로 사용할 레이아웃을 만들어야 한다. 글쓰기 페이지, 게시글 상세 페이지,게시글 리스트 페이지에 공통으로 적용되는 headr 와 body를 만들어보자. 먼저, thymeleaf 기능을 이용하기 위해서 라이브러리를 추가한다. build.gradle 의 dependencies에 다음 라이브러리를 선언한다. 선언 위치는 implementation 끼리 모아두어야한다. 라이브러리 선언한 후, 프로젝트에 확실하게 적용하기 위해서 verdeterr 프로젝트를 우클릭한 후 gradle-Refresh-Gradel Project 다음으로 헤더(header)와 바디(body)를 만든다. src&#x2F;main&#x2F;resource 디렉터리의 templates&#x2F;survey&#x2F;fragments 와 layout 패키지를 만들어준다 fragments 패키지에 header.html ,body.html 을 추가한다. header.html th:fragment : 태그에 해당 속성을 사용하여 fragment의 이름을 지정한다. th:block: layout:fragment 속성에 이름을 지정하여 실제 Content 페이지의 내용을 채우는 기능이다. 해당 기능은 동적처리가 필요할때 사용된다. th:href: 태그의 href 속성과 동일하며, JSTL의 &lt;c:url&gt; 태그와 마찬가지로 웹 어플리케이션을 구분하는 콘텍스트 경로를 포함한다. application.properties에서 콘텍스트 경로를 원하는 경로로 변경 가능하다. body.html search: 게시글 리스트 페이지의 검색 영역으로 검색처리에 사용된다. content: 페이지별로 실제 Content가 들어가는 영역이다. Paging: 게시글 리스트 하단의 페이지네이션 영역으로 페이징 처리에 사용된다. add-content:추가되는 Content가 들어가는 영역으로 댓글처리를 진행하면서 사용된다. 레이아웃 폴더의 basic.html을 인클루드 해보자. xmlns:th : thymeleaf의 th 속성을 사용하기 위한 선언이다. xmlns:layout : thymeleaf 의 layout 속성을 사용하기 위한 선언이다\\ xmlnslayout:decorate : 레이아웃으로 basic.html 을 사용하겠다는 의미이다. th:block layout:fragment: layout:fragment 속성에 이름을 지정하여 실제 Content에 내용을 채우게 된다. 예를들어, 글쓰기 페이지는 “write page”, 게시글 리스트 페이지는 “list page” 로 페이지마다 타이틀을 다르게 처리하고 싶을때 해당 속성을 이용하여 동적 처리가 가능하다 게시글 등록창 구현 - boardController 의 openBoardWrite 함수 @RequestParam: 뷰에서 전달받은 파라미터를 처리하는데 사용된다. 예를들어, 게시글 리스트페이지에서 게시글 등록페이지로 이동하면, 게시글 번호(idx) null 로 전송된다. 하지만 게시글 상세 페이지에서 수정하기 버튼을 클릭하면, 컨트롤러로 게시글 번호(idx)가 파라미터로 전송되고, 컨트롤러는 전달받은 게시글 번호(idx)를 getboardDetail 메서드의 인자로 전달한다. 새로운 게시글 등록하는 경우, 컨트롤러는 전달받은 게시글 번호(idx)가 필요하지 않기 때문에 required 속성을 false로 지정한다. 필수(required) 속성은 default 값이 true이며, required 속성을 false로 지정하지 않으면 idx가 파라미터로 전송되지 않았을때 오류가 발생한다. &lt;게시글 등록페이지로 넘어가지고, idx&#x3D;null 이라서 똑같은 write.html 을 리턴하지만, view 로 넘겨지는 것들이 달라진다. 그리하여 , idx가 null로 넘어오면 board 객체를 빈 객체를 넘겨준다.&gt; &lt; 그와 반대로 , idx가 있는상태로 넘어오면, boardservice.geboardDetail(idx) 가 실행되어 지면서 , 게시글의 상세사항을 가지고 board 라는 이름으로 넘겨진다.&gt; 다음으로 글쓰기 페이지에 글을 작성할 수 있는 영역(Content)를 포함시켜본다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889&lt;!DOCTYPE html&gt;&lt;html lang=&quot;ko&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot; xmlns:layout=&quot;http://www.ultraq.net.nz/thymeleaf/layout&quot; layout:decorate=&quot;board/layout/basic&quot;&gt;&lt;th:block layout:fragment=&quot;title&quot;&gt; &lt;title&gt;The page is a write page&lt;/title&gt;&lt;/th:block&gt;&lt;th:block layout:fragment=&quot;content&quot;&gt; &lt;div class=&quot;card-content&quot; style=&quot;margin: 10% 10% 0 30%&quot;&gt; &lt;form class=&quot;form-horizontal&quot; th:action=&quot;@&#123;/board/register&#125;&quot; th:object=&quot;$&#123;board&#125;&quot; method=&quot;post&quot; onsubmit=&quot;return registerBoard(this)&quot;&gt; &lt;!--/* update의 경우 서버로 전달할 게시글 번호 (PK) */--&gt; &lt;input type=&quot;hidden&quot; th:if=&quot;*&#123;idx != null and idx &gt; 0&#125;&quot; th:field=&quot;*&#123;idx&#125;&quot; /&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;title&quot; class=&quot;col-sm-2 control-label&quot;&gt;제목&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;input type=&quot;text&quot; th:field=&quot;*&#123;title&#125;&quot; class=&quot;form-control&quot; placeholder=&quot;제목을 입력해 주세요.&quot; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot; style=&quot;display:none;&quot;&gt; &lt;label for=&quot;postType&quot; class=&quot;col-sm-2 control-label&quot;&gt;유형&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;!-- name=백단에 저장될 이름 --&gt; &lt;input readonly th:value=&quot;$&#123;type&#125;&quot; name=&quot;postType&quot; class=&quot;form-control&quot; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label class=&quot;col-sm-2 control-label&quot;&gt;유형&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;!-- name=백단에 저장될 이름 --&gt; &lt;input readonly th:value=&quot;|$&#123;charName&#125; ($&#123;charTitle&#125;)|&quot; class=&quot;form-control&quot; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;content&quot; class=&quot;col-sm-2 control-label&quot;&gt;내용&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;textarea th:field=&quot;*&#123;content&#125;&quot; class=&quot;form-control&quot; placeholder=&quot;내용을 입력해 주세요.&quot;&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot; th:if=&quot;$&#123;session.user.isManagerYn()&#125;==true&quot;&gt; &lt;label for=&quot;noticeYn&quot; class=&quot;col-sm-2 control-label&quot;&gt;공지글 여부&lt;/label&gt; &lt;input type=&quot;checkbox&quot; th:value=&quot;*&#123;noticeYn&#125;&quot; id=&quot;NoticeYn&quot; name=&quot;NoticeYn&quot; th:checked=&quot;*&#123;noticeYn&#125;&quot; /&gt; &lt;!-- 체크박스가 checked 되면 그 값에 noticeYn 에 true를 넣어라 아직 value 에는 그것이 저장이 안됨 이제 function 으로 넘어가라 --&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;btn_wrap text-center&quot; style=&quot;margin-right: 30%;&quot;&gt; &lt;br&gt; &lt;a th:href=&quot;@&#123;/board/list(type=$&#123;type&#125;)&#125;&quot; class=&quot;btn btn-secondary waves-effect waves-light&quot;&gt;뒤로가기&lt;/a&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary waves-effect waves-light&quot;&gt;저장하기&lt;/button&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;!-- /.card-content --&gt;&lt;/th:block&gt;&lt;th:block layout:fragment=&quot;script&quot;&gt; &lt;script th:inline=&quot;javascript&quot;&gt; /*&lt;![CDATA[*/ function registerBoard(form) &#123; form.NoticeYn.value = (form.NoticeYn.checked == true ? true : false); //function 으로 넘어가게 되면 value에 checked 가 true이면, value 에 true값 저장 // 그게 아니면 value에 false값 저장. var result = ( isValid(form.title, &quot;제목&quot;, null, null) &amp;&amp; isValid(form.writer, &quot;이름&quot;, null, null) &amp;&amp; isValid(form.content, &quot;내용&quot;, null, null) ); if (result == false) &#123; return false; &#125; &#125; /*[- end of function -]*/ /*]]&gt;*/ &lt;/script&gt;&lt;/th:block&gt;&lt;/html&gt; layout:fragment&#x3D;”content” : 게시글 등록 페이지는 게시글의 정보를 입력할 수 있는 폼이 필요하고, 게시글 리스트 페이지는 게시글의 정보를 보여주는 테이블이 필요하다. title과 마찬가지로 페이지마다 Content의 내용이 다르기 때문에 layout:fragment를 이용한다. 태그 : 폼은 태그 안에 선언되어 있는 input,textarea등, 사용자 입력 필드의 “name” 속성값을 기준으로 th:action 속성에 지정된 url과 매핑된 컨트롤러의 메서드로 폼 데이터(파라미터)를 전달한다 method 속성에는 HTTP 요청 메서드를 지정한다. HTTP 요청 메소드는 대표적으로 Get 과 POST가 사용되는데, GET은 데이터의 조회, POST는 데이터의 생성을 의미한다. Onsubmit은 폼 데이터를 컨트롤러에 전송하기 전에 폼데이터의 유효성을 검사하거나 할 때 사용하는 이벤트다. 함수명 앞에 return이 선언된 이유는 자바스크립트 이벤트가 기본적으로 return true의 성향을 가지기 떄문이다. return이 선언되지 않으면, 폼을 submit 했을때 함수를 실행하지 않고 바로 컨트롤러를 실행하는 문제가 생긴다. th:object : th:object 속성의 “${board}”는 컨트롤러에서 뷰로 전달한 BoardDTO 클래스의 객체(인스턴스)이다. 해당 속성을 이용하면 th:field를 이용하여 HTML 태그에 멤버변수를 매핑할 수 있다. th:field를 이용한 사용자 입력필드 (input,textarea등) id,name,value 속성 값이 자동으로 매핑되므로, 각 속성을 따로 지정할 필요가 없다 . th:field는 ${} 표현식이 아닌 *{}표현식을 사용한다 . th:object와 th:field 는 컨트롤러에서 특정 클래스의 객체를 전달받은 경우에만 사용할 수 있다. noticeYn 과 secretYn의 경우에는 th:field를 이용하면 게시글을 수정할 때 두 필드가 무조건 checked 되는 문제가 발생하기 떄문에 따로 name 속성을 지정한다. 저장하기: 저장하기 버튼의 type은 submit으로 지정되어 있는데, 만약 type 속성이 button 이거나 폼 태그 밖에 있으면, 해당 버튼 클릭을했을때, submit 이벤트가 발생하지 않는다. layout:fragment&#x3D;”script” : 자바스크립트도 페이지마다 로직이 다르기 때문에 layout:fragment 를 이용한다. th:inline&#x3D;”javascript” : script 태그에 th:inline 속성을 javascript로 지정해야 자바스크립트를 사용할 수 있다, : thymeleaf는 ‘&lt;’,’&gt;’ 태그를 엄격하게 검사하기 때문에 자바스크립트 코드는 반드시 CDATA로 묵어 주어야 한다. CDATA는 특수문자를 모두 문자열로 치환할 때 사용된다. registerBoard 함수: 폼의 onsubmit 이벤트에 해당 함수를 선언하면서 인자로 this를 선언한다. this는 자기 자신(폼 객체)를 의미한다. 자바스크립트 영역의 registerBoard 함수는 전달받은 this를 form이라는 이름의 파라미터로 사용한다. 해당 함수의 전체로직 noticeYn 과 secretYn 체크 여부에 따라 값을 지정한다. 2)result 변수에 isValid(유효성 검사) 함수를 실행한 결과를 저장한다 isValid 함수는 필수적으로 입력되어야 하는 필드 유효성을 판단하는 기능을 하고 제목,작성자,내용은 필수적인 데이터기 떄문에 유효성 검사가 반드시 이루어져야 한다. 마지막으로, BoardController 클래스의 폼 태그의 th:action 속성에 지정한 게시글 등록을 처리하는 registerBoard 메서드를 다음과 같이 작성한다. Params: 폼 엘리먼트의 사용자 입력 필드의 name 속성을 통해 폼 데이터를 컨트롤러에서 메서드의 파라미터로 전달한다. BoardDTO의 멤버 변수명과 사용자 입력필드의 name 속성 값이 동일하면 params의 각 멤버 변수에 name 속성 값을 통해 전달된 value가 매핑된다. 그러면 그 view단에서 가져온 paramas 를 그대로 담아서 boardService.registerBoard 를 실행시키면 되는것 이다.","categories":[{"name":"Development","slug":"Development","permalink":"https://kimyoungjae777.github.io/categories/Development/"},{"name":"Verdeterr(웹프로젝트)","slug":"Development/Verdeterr-웹프로젝트","permalink":"https://kimyoungjae777.github.io/categories/Development/Verdeterr-%EC%9B%B9%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/"}],"tags":[{"name":"Development","slug":"Development","permalink":"https://kimyoungjae777.github.io/tags/Development/"},{"name":"Verdeterr(웹프로젝트)","slug":"Verdeterr-웹프로젝트","permalink":"https://kimyoungjae777.github.io/tags/Verdeterr-%EC%9B%B9%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/"}],"author":"Young Jae Kim"},{"title":"camelCase와snake_case의 차이","slug":"Camel_case VS Snake_case d8930e4a85bc460c91d19cc6ae716c7b","date":"2022-11-09T00:00:00.000Z","updated":"2023-04-14T14:29:10.409Z","comments":true,"path":"2022/11/09/Camel_case VS Snake_case d8930e4a85bc460c91d19cc6ae716c7b/","link":"","permalink":"https://kimyoungjae777.github.io/2022/11/09/Camel_case%20VS%20Snake_case%20d8930e4a85bc460c91d19cc6ae716c7b/","excerpt":"","text":"Camel_case VS Snake_case 카멜 케이스 표기법 (camelCase) 첫 문자는 소문자로 표기하고 그 이후에 연결되는 문자들의 첫자는 대문자로 표기 ex) camelCase ,androidStudio 2.스네이크 케이스 표기법 (snake_case) 모든 문자의 첫 자는 소문자로 표기하고 문자들 사이는 _(언더바)로 연결 ex)snalke_case , android_studio","categories":[{"name":"Development","slug":"Development","permalink":"https://kimyoungjae777.github.io/categories/Development/"},{"name":"기본개념","slug":"Development/기본개념","permalink":"https://kimyoungjae777.github.io/categories/Development/%EA%B8%B0%EB%B3%B8%EA%B0%9C%EB%85%90/"}],"tags":[{"name":"Development","slug":"Development","permalink":"https://kimyoungjae777.github.io/tags/Development/"},{"name":"기본개념","slug":"기본개념","permalink":"https://kimyoungjae777.github.io/tags/%EA%B8%B0%EB%B3%B8%EA%B0%9C%EB%85%90/"}],"author":"Young Jae Kim"},{"title":"웹페이지 만들기.1(Verdeterr)게시판 생성부터 mybatis 설정까지","slug":"웹페이지만들기","date":"2022-11-07T00:00:00.000Z","updated":"2023-04-14T14:29:10.473Z","comments":true,"path":"2022/11/07/웹페이지만들기/","link":"","permalink":"https://kimyoungjae777.github.io/2022/11/07/%EC%9B%B9%ED%8E%98%EC%9D%B4%EC%A7%80%EB%A7%8C%EB%93%A4%EA%B8%B0/","excerpt":"","text":"웹페이지 만들기 프로젝트(게시판 생성부터 MyBatis 설정까지 )1.스프링 프레임워크 다운로드스프링 다운로드 주소: https://spring.io/tools 사용할 버젼:Spring Tools 4 2. 스프링 프레임워크 설치하기1)JAVA JDK : 자바를 설치 하여준다. 현재 자바는 버전 15까지 나와있다. 참고로 스프링 프레임워크에 호환되는 버젼은 JDK 8&#x2F;JDK 11 &#x2F;JDK 15가 있다. 스프링프레임워크를 다운로드한 압축파일의 압축을 푼다. 여기서 중요한 것은 스프링 프레임워크 역시 압축파일 안에 이름이 엄청나게 긴 파일이 있기 때문에 반드시 압축을 풀 때 이클립스 설치와 마찬가지로 C 드라이브에 풀어야한다. 위에서 설치한 sts 폴더 안에서 Spring ToolSuite4.ini 파일이 있다. 이 파일을 에디터나 메모장으로 실행하여 다음과 같이 설정한다 10번 줄은 각자 pc에 설치해놓은 자바 jdk의 경로와 일치시키면 된다. 14~15번 줄은 JVM이 사용하는 힙 메모리의 시작, 최대 사이즈를 나타내는 것이다. 두 값을 일치시키면 STS의 버벅거림이 조금 나아진다 . 프로젝트 생성STS에서 FILE-NEW-Spring Starter Project를 클릭하여 새 프로젝트를 생성한다. 프로젝트 이름을 정하고 위와 같이 설정해준다. 여기서 type는 gradle 로 설정해주는게 제일 중요하다. gradel은 Maven을 대신하여 라이브러리를 관리해준다. 이렇게 verdeterr 라는 스프링 프로젝트가 완성되고, 스프링부트는 개발에 필요한 몇가지 설정들을 처리해주는데 기본적으로 톰캣 서버를 내장하고 있어서 별도로 WAS(Web Application Server)를 설치하지 않아도 된다. 또한 java build path 같은 것들도 신경쓰지 않아도 된다. DB와 스프링 연결하기 DBEAVER 를 통해서 데이터베이스를 만들어준다. jdbc-url: 데이터베이스의 주소 , 포트번호 뒤의 board는 스키마의 이름 ,serverTimezone 등의 파라미터는 기본설정을 처리함 . username:MySQL 아이디 Password:MYSQL 비밀번호 connection-test-query: 커넥션이 정상적으로 연결되었는지 확인하는 SQL DBConfiguration.java 클래스 생성 @Configuration : 스프링은 @Configuration이 지정된 클래스를 자바 기반의 설정 파일로 인식한다. @PropertySource : 해당 클래스에서 참조할 properties 파일의 위치를 지정한다. @Autowired : Bean으로 등록된 인스턴스(객체)를 클래스에 주입하는데 사용된다. @Autowired 이외에도 @Resource, @Inject 등이 있다. ApplicationContext : 스프링 컨테이너(Spring Container) 중 하나다. 스프링 컨테이너는 Bean의 생성과 사용, 관계, 생명주기 등을 관리한다. Bean : 쉽게 말해서 객체를 말한다. Configuration 클래스의 메서드 레벨에만 지정이 가능하다. @Bean 지정된 객체는 컨테이너에 의해 관리되는 Bean으로 지정된다. @ConfigurationProperties : 해당 애너테이션은 인자에 prefix 속성을 지정할 수 있다. 이 프로젝트에서는 prefix에 spring.datasource.hikari를 지정했는데, @PropertySource에서 지정된 파일(application.properties)에서 prefix에 해당하는 spring.datasource.hikari로 시작하는 설정을 모두 읽어들여 메서드에 매핑(바인딩)한다. hikariConfig : 히카리CP 객체를 생성한다. 히카리CP는 커넥션 풀(Connection Pool) 라이브러리의 하나다. datasource : 데이터 소스 객체를 생성한다. 순수 JDBC는 SQL을 실행할 때마다 커넥션을 끊고 맺는 I&#x2F;O 작업을 한다. 이 작업은 상당한 리소스를 잡아먹기 때문에 커넥션 풀이 등장했다. 커넥션 풀은 커넥션 객체를 생성해두고, 데이터베이스에 접근하는 사용자에게 미리 생성해둔 커넥션을 제공했다가 다시 돌려받는 방법이다. 데이터 소스는 커넥션 풀을 지원하기 위한 인터페이스다. sqlSessionFactory : SqlSessionFactory 객체를 생성한다. 데이터베이스의 커넥션과 SQL 실행에 대한 모든 것을 갖는 중요한 역할을 한다. SqlSessionFactoryBean은 MyBatis와 Spring의 연동 모듈로 사용된다. MyBatis XML Mapper, 설정 파일 위치 등을 지정하고 SqlSessionFactoryBean 자체가 아닌 getObject 메서드가 리턴하는 SqlSessionFactory를 생성한다. sqlSession : sqlSession 객체를 생성한다. SqlSessionTemplate는 SqlSessionFactory를 통해 생성된다. 데이터베이스 커밋, 롤백 등 SQL 실행에 필요한 모든 메서드를 갖는 객체다. 1. 게시판 테이블 생성- MYSQL을 통해서, 게시판 테이블을 만들어준다. com.board.domain 에 BoardDTO를 만들어준다. 게시판 테이블의 구조화 역할을 하는 클래스를 생성해보자. 입력받은 데이터의 저장 및 전송을 하는 DTO 클래스를 생성한다. 클래스 이름은 BoardDTO 라고 한다. Controller,domain,mapper,service,mapper 패키지를 생성하여준다. Mapper 인터페이스 생성하기 데이터베이스와의 통신 역할을 하는 Mapper 인터페이스를 만든다. mapper 패키지에 BoardMapper 클래스를 생성하고 다음의 코드를 작성한다. Board Mapper의 각종 어노테이션과 함수정리 @Mapper :MyBatis는 인터페이스에 @Mapper만 지정해주면 XML Mapper 에서 메서드의 이름과 일치하는 SQL문을 찾아 실행해 준다. insertBoard: 게시글을 생성하는 INSERT 쿼리를 호출하는 메서드이다. 파라미터로 BoardDTO 클래스가 params 라는 이름으로 지정되었다. params 에는 게시글의 정보가 담긴다. selectBoardDetail: 하나의 게시글을 조회하는 select 쿼리를 호출하는 메서드다. select 쿼리가 실행되면 각 컬럼에 해당하는 결괏값이 리턴타입으로 지정된 BoardDTO 클래스의 멤버 변수에 매핑된다. 파라미터로는 게시글 번호(IDX),즉 PK를 전달받으며, WHERE 조건으로 idx를 사용해서 특정 게시글을 조회한다. updateBoard: 게시글을 수정하는 update 쿼리를 호출하는 메서드다. 파라미터로는 BoardDTO 클래스가 params라는 이름으로 지정되었고, insertBoard 메서드와 마찬가지로 params에는 게시글의 정보가 담긴다. deleteBoard: 게시글을 삭제하는 DELETE 쿼리를 호출하는 메서드다. 테이블을 생성하면서 delete_yn 칼럼을 추가했는데, 해당 칼럼은 실제로 데이터를 삭제하지 않고, delete_yn에1 로 되어있는 행은 추출하지 않는 방식을 뜻한다. 중요한 데이터를 영구삭제 시켜버리면 피해가 크기 때문에 요즘 사용하는 방식이다. selectBoardCount: 삭제 여부 가 0으로 지정된 게시글의 개수를 조회하는 select 쿼리를 호출하는 메서드이다. 페이징 처리 진행에 사용된다. MyBatis XML Mapper 생성 BoardMapper와 sql문의 연결을 위해 mybatis xml mapper에 sql문을 작성한다. 먼저, src&#x2F;main&#x2F;resources 디렉터리에 mapper 패키지를 생성한다. Board Mapper XML 의 ID값과 BoardMapper 인터페이스랑 매칭이 되어서 , 데이터베이스와 연동이 되는 것 이다. 그냥 XML 파일을 사용해도 되긴하지만, MyBatis XML Mapper 는 자동완성을 제공한다. : MyBatis 에서 SQL 쿼리문이 정의된 파일을 XML Mapper 라고 한다 . 태그를 여는 부분에 namespace 속성이 정의되어 있는데, BoardMapper 인터페이스의 경로가 지정되어 있다. 이 namespace는 xml mapper의 sql 쿼리문과 boardmapper 인터페이스의 메서드를 매핑하기 위해 지정하는 속성이다. : MyBatis는 태그를 이용하여 태그의 시작과 끝 사이에 공통으로 사용되거나 반복적으로 사용되는 sql 조각을 정의할 수 있다. ⇒ 번거로운 과정을 줄이기 위해, post 테이블의 컬럼 전체를 boarcdcolumns 로 지정하여 주고, 재사용하면 된다. parameterType:쿼리 실행에 필요한 파라미터 타입을 해당 속성에 지정한다. resultType:쿼리 실행결과를 매핑할 타입을 지정한다. 파라미터 표현식 :전달받은 파라미터는 #{} 표현식을 사용해서 처리한다. MyBatis SELECT 컬럼과 DTO 멤버 변수 매핑 MyBatis 에서 SELECT 쿼리의 결과 컬럼은 DTO 클래스 멤버 변수와 매핑된다. XML Mapper의 boardColumns SQL 조각은 언더바 로 연결하는 스네티크 케이스를 사용한다. 하지만 자바에서 변수의 이름은 소문자로 시작하고, 구분되는 단어는 앞 글자만 대문자로 처리하는 카멜 케이스를 사용한다. 이러한 경우에 MyBatis의 map-underscore-to-camel&#x3D;case&#x3D;true 설정을 사용하여 자동으로 매핑되도록 처리한다. src&#x2F;main&#x2F;resource 디렉터리의 application.properties의 하단에 위의 코드를 추가 . DBConfiguration 클래스 처리application.properties에 MyBatis 설정을 추가했다. 이제 해당 설정을 처리할 Bean을 정의해야 한다. setMapperLocation: 이 메서드는 getResources 메서드의 인자로 지정된 패턴에 포함되는 XML Mapper를 인식하도록 하는 역할을 한다. setTypeAliasesPackage: BoardMapper XML 에서 ParameterType 과 BoardMapper XML에서 parameterType 과 resultType은 클래스의 경로가 포함되어 있어야 하는데, 이 메서드를 사용하여 풀 패키지 경로를 생략하고 BoardDTO와 같이 클래스 이름만 지정하여 사용할 수 있다. ⇒ resultType 과 parameterType 에서 경로를 다 써줄수 없으니까 미리 경로를 설정해주는 세팅 mybatisConfig: application.properties 에서 mybatis.configuration 으로 시작하는 모든 설정을 읽어들여 Bean으로 등록한다. setConfiguration : 위 코드의 63~70 라인에 추가된 Mybatis 설정과 Bean을 설정 파일로 지정한다.","categories":[{"name":"Development","slug":"Development","permalink":"https://kimyoungjae777.github.io/categories/Development/"},{"name":"Verdeterr(웹프로젝트)","slug":"Development/Verdeterr-웹프로젝트","permalink":"https://kimyoungjae777.github.io/categories/Development/Verdeterr-%EC%9B%B9%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/"}],"tags":[{"name":"Development","slug":"Development","permalink":"https://kimyoungjae777.github.io/tags/Development/"},{"name":"Verdeterr(웹프로젝트)","slug":"Verdeterr-웹프로젝트","permalink":"https://kimyoungjae777.github.io/tags/Verdeterr-%EC%9B%B9%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/"}],"author":"Young Jae Kim"},{"title":"AOP ","slug":"AOP(Aspect Oriented Programming) 4df70bbdfd2242e3bfe343f948bee5d1","date":"2022-08-06T00:00:00.000Z","updated":"2023-04-14T14:29:10.408Z","comments":true,"path":"2022/08/06/AOP(Aspect Oriented Programming) 4df70bbdfd2242e3bfe343f948bee5d1/","link":"","permalink":"https://kimyoungjae777.github.io/2022/08/06/AOP(Aspect%20Oriented%20Programming)%204df70bbdfd2242e3bfe343f948bee5d1/","excerpt":"","text":"AOP(Aspect Oriented Programming)REFERENCE:스프링 부트(Spring Boot) - AOP와 트랜잭션(Transaction) 설정하기 [개발을 시작해봐요!] (tistory.com)AOP는 관점 지향 프로그래밍입니다. AOP는 자바와 같은 객체 지향 프로그래밍을(OOP)을 더욱 OOP 답게 사용할 수 있도록 도와주는 역할을 합니다. AOP는 여러 개의 핵심 비즈니스 로직 외에 공통적으로 처리되어야 하는 로그출력,보안처리,예외처리와 같은 코드를 별도로 분리해서 하나의 단위로 묶는 모듈화의 개념으로 생각할 수 있습니다. 하나의 단위로 묶는 모듈화의 개념으로 생각할 수 있습니다 AOP에서 관점에서 관점은 핵심적인 관점과 부가적인 관점으로 나눌수 있습니다. 핵심적인 관점은 핵심 비즈니스 로직을 의미하고, 부가적인 관점은 앞에서 이야기한 공통으로 처리되어야 하는 코드를 의미합니다. 각각의 화살표는 하나의 기능을 구현하는데 필요한 작업을 의미. MVC 패턴의 특성상, 컨트롤러 ⇒ 서비스 ⇒DAO(Mapper) tnsdmfh wkrehdgkqslek. 필수적으로 처리되어야 하는 로그,보안,트랜잭션,예와처리와 같은 부가적인 기능들이 정말 규모가 커다란 시스템에서 각각의 기능에 추가된다면 코드가 엄청나게 길어진다. AOP는 이러한 문제를 관점이라는 개념을 통해 해결할 수 있습니다 앞에서 이야기 했던 부가적인 관점에서는 핵심 비즈니스 로직이 어떤 기능을 수행하는지에 대해 전혀 알 필요가 없습니다. 단지, 핵심 비즈니스 로직 안에서 필요한 시점에 부가적인 관점이 포함되기만 하면 된다. 객체 지향 프로그래밍과 달리, 부가적인 관점이 핵심 비즈니스 로직의 바깥에 포함되어 있다. AOP를 적용하면 로그,보안,트랜잭션,예외처리와 같은 부가적인 기능들을 일일이 추가하지 않아도 된다. 어노테이션에 대한 표 어노테이션에 대한 표","categories":[{"name":"Development","slug":"Development","permalink":"https://kimyoungjae777.github.io/categories/Development/"},{"name":"기본개념","slug":"Development/기본개념","permalink":"https://kimyoungjae777.github.io/categories/Development/%EA%B8%B0%EB%B3%B8%EA%B0%9C%EB%85%90/"}],"tags":[{"name":"Development","slug":"Development","permalink":"https://kimyoungjae777.github.io/tags/Development/"},{"name":"기본개념","slug":"기본개념","permalink":"https://kimyoungjae777.github.io/tags/%EA%B8%B0%EB%B3%B8%EA%B0%9C%EB%85%90/"}],"author":"Young Jae Kim"},{"title":"IN연산자","slug":"IN연산자","date":"2022-08-06T00:00:00.000Z","updated":"2023-04-14T14:29:10.415Z","comments":true,"path":"2022/08/06/IN연산자/","link":"","permalink":"https://kimyoungjae777.github.io/2022/08/06/IN%EC%97%B0%EC%82%B0%EC%9E%90/","excerpt":"","text":"SQL IN 연산자 SQL IN 구문은 WHERE절 뒤에 붙어서 칼럼이 특정값을 가지고 있는지 확인하는 용도로 쓰입니다. 사용법12345SELECT 칼럼명 FROM 테이블명 WHERE 컬럼명 IN(값1,값2)## 칼럼의 값이 값1 또는 값2에 해당하는 값만 출력SELECT 칼럼명 FORM 테이블명 WHERE 칼럼명 NOT IN(값1,값2)## 칼럼의 값이 값1,값2 어디에도 해당하지 않는 것만 출력SELECT * FROM member WHERE name IN(&#x27;제갈량&#x27;,&#x27;강감찬) name 칼럼에 제갈량 또는 강감찬 값을 가진 데이터만 출력이 되어서 제갈량과 강감찬 row 만 출력이 됩니다.","categories":[{"name":"Development","slug":"Development","permalink":"https://kimyoungjae777.github.io/categories/Development/"},{"name":"DataBase","slug":"Development/DataBase","permalink":"https://kimyoungjae777.github.io/categories/Development/DataBase/"}],"tags":[{"name":"Development","slug":"Development","permalink":"https://kimyoungjae777.github.io/tags/Development/"},{"name":"DataBase","slug":"DataBase","permalink":"https://kimyoungjae777.github.io/tags/DataBase/"}],"author":"Young Jae Kim"},{"title":"SQLD 준비","slug":"SQLD","date":"2022-08-06T00:00:00.000Z","updated":"2023-04-14T14:29:10.421Z","comments":true,"path":"2022/08/06/SQLD/","link":"","permalink":"https://kimyoungjae777.github.io/2022/08/06/SQLD/","excerpt":"","text":"SQLD1.데이터 모델링 데이터 모델링은 현실 세계를 데이터베이스로 표현하기 위해서 추상화한다. 데이터 모델링을 하기 위해서는 고객과의 의사소통을 위해 업무 프로세스를 이해해야 한다. 고객의 업무 프로세스를 이해한 후 데이터 모델링 표기법을 사용해서 모델링을 한다. 고객의 업무 프로세스를 이해한 후 데이터 모델링 표기법을 사용해서 모델링을 한다. 데이터 모델링은 고객의 업무 프로새스를 추상화하고, 소프트웨어를 분석,설계 하면서 점점 더 상세해진다. 데이터 모델링은 고객의 비즈니스 프로세스를 이해하고 비즈니스 프로세스의 규칙을 정의한다. 정의된 비즈니스 규칙을 데이터 모델로 표현한다. 데이터 모델링의 특징 데이터 모델링은 추상화 해야한다 →추상화는 공통적인 특징을 찾고 간략하게 표현한다 데이터 모델링은 단순화 해야한다 →복잡한 문제를 피하고 누구나 이해할 수 있게 표현한다 데이터 모델링은 명확 해야한다→ 의미적 해석이 모호하지 않고 명확하게 해석되어야 한다. 데이터 모델링 단계1)개념적 모델링 고객의 비즈니스 프로세스를 분석하고 업무 전체에 대해서 데이터 모델링을 수행한다. 복잡하게 표현하지 않고 중요한 부분을 위주로 모델링하는 단계이다 업무적 관점에서 모델링하며 기술적인 용어는 가급적 사용하지 않는다. 엔터티와 속성을 도출하고, 개념적 ERD(Entity Relationship Digram)을 작성한다. 2)논리적 모델링 개념적 모델링을 논리적 모델링으로 변환하는 작업이다 식별자를 도출하고 필요한 모든 릴레이션을 정의한다 정규화를 수행해서 데이터 모델의 독립성을 확보한다 3)물리적 모델링 데이터베이스를 실제 구축한다. 즉 테이블,인덱스,함수 등을 생성한다 성능,보안,가용성을 고려해서 구축한다 개념적모델링- 전사적 관점에서 기업의 데이터를 모델링한다 - 추상화 수준이 가장 높은 수준의 모델링이다. - 계층형 데이터모델,네트워크 모델, 관계형 모델에 관계없이 업무 측면에서 모델링. 논리적 모델링-특정 데이터베이스 모델에 종속한다 -식별자를 정의하고 관계 속성 등을 모두 표현한다 -정규화를 통해서 재사용성을 높인다 물리적 모델링 - 구축할 데이터베이스 관리시스템에 테이블,인덱스 등을 생성하는 단계이다 - 성능,보안,가용성 등을 고려하여 데이터베이스를 구축한다. 데이터 모델링 관점데이터 - 비즈니스 프로세스에서 사용되는 데이터를 의미한다 - 구조분석,정적분석 프로세스 -비즈니스 프로세스에서 수행하는 작업을 의미한다 - 시나리오 분석,도메인 분석, 동적 분석 데이터와 프로세스- 프로세스와 데이터 간의 관계를 의미한다 - CRUD(Create,Read,Update,Delete) 분석 ERD1.엔터티를 도출하고 그린다 업무에서 관리해야 하는 집을 도출한다. 2.엔터티를 배치한다 엔터티를 도출한 후 엔터티를 배치한다. 중요한 엔터티를 왼쪽 상단에 배치한다 3.엔터티 간의 관계를 설정한다 4.관계명을 서술한다. -엔터티 간의 어떤 행위나 존재가 있는지 표현한다. 5.관계 참여도를 표현한다 관계 참여도는 한 개의 엔터티와 다른 엔터티 간의 참여하는 관계 수를 의미한다. 즉,”고객이 여러개의 계좌를 개설할 수 있다” 와 같은 의미를 표현하는 것이다. 6.관계의 필수 여부를 표현한다 필수는 반드시 존재해야 하는 것이다. 예를들어 “모든 고객은 반드시 하나의 계좌를 개설해야 한다.” 와 같은 의미를 표현한다. ERD 작성시 고려사항 중요한 엔터티를 가급적 왼쪽 상단에 배치한다 ERD는 이해가 쉬워야 하고 너무 복잡하지 않아야한다. 데이터 모델링 고려사항(1)데이터 모델의 독립성 독립성이 확보된 모델은 고객의 업무 변화에 능동적으로 대응할 수 있다. 독립성을 확보하기 위해서는 중복된 데이터를 제거해야한다. 데이터 중복을 제거하는 방법이 바로 정규화이다. (2)고객 요구사항의 표현 데이터 모델링으로 고객과 데이터 모델러 간에 의사소통을 할 수 있어야 하므로, 고객의 요구 사항을 간결하고 명확하게 표현해야 한다. (3)데이터 품질 확보 데이터베이스 구축 시에 데이터 표준을 정의하고 표준 준수율을 관리해야 한다. 데이터 표준을 확보해야 데이터 품질을 향상 시킬수 있다. 3층 스키마(3-LEVEL Schema) 사용자,설계자 개발자가 데이터베이스를 보는 관점에 따라 데이터베이스를 기술하고 이들 간의 관계를 정의한 ANSI 표준이다 3층 스키마는 데이터베이스의 독립성을 확보하기 위한 방법이다. 데이터의 독립성을 확보하면 데이터 복잡도 감소, 데이터 중복 제거,사용자 요구사항 변경에 따른 대응력 향상, 관리 및 유지보수 비용 절감 등의 장점을 갖는다. 3단계 계층으로 분리해서 독립성을 확보하는 방법으로 각 계층을 뷰라고도 한다. 3층 스키마의 독립성 논리적 독립성- 개념 스키마가 변경되더라도 외부 스키마가 영향을 받지 않는 것이다 물리적 독립성- 내부스키마가 변경되더라도, 개념 스키마가 영향을 받지 않는것이다. 외부스키마-사용자 관점, 업무상 관련이 있는 데이터 접근이다. -관련 데이터베이스의 뷰를 표시한다. -응용프로그램이 접근하는 데이터베이스를 정의한다. 개념스키마-설계자 관점,사용자 전체집단의 데이터베이스 구조이다 -전체 데이터베이스 내의 규칙과 구조를 표현한다. -통합 데이터베이스 구조이다. 내부스키마-개발자관점,데이터베이스의 물리적 저장구조이다. -데이터 저장구조,레코드 구조, 필드정의,인덱스 등을 의미한다. 엔터티 엔터티는 업무에서 관리해야 하는 데이터 집합을 의미하며, 엔터티는 개념,사건,장소 등의 명사이다. 엔터티 도출 엔터티는 고객의 비즈니스 프로세스에서 관리되어야 하는 정보를 추출해야 한다. 다음의 예를 통해 업무에서 관리해야 하는 엔터티를 도출해보자. ex) 1.고객이 회원가입을 한다. 회원으로 가입할 때는 회원ID,패스워드,이름,주소,전화번호 등을 입력해야한다. 2.회원으로 가입하기 위해서는 반드시 하나의 계좌를 개설해야 한다. 3.고객은 계좌를 여러 개 개설할수 있다. 4.계좌를 개설할때는 계좌번호,계좌명,예수금,계좌개설,계좌담당자가 입력된다 . 위의 시나리오 에서 엔터티를 도출하면 다음과 같다. 엔터티의 특징식별자- 엔터티는 유일한 식별자가 있어야 한다. ex)회원 id,계좌번호 인스턴스집합- 2개 이상의 인스턴스가 있어야한다. 속성-엔터티는 반드시 속성을 가지고 있다. ex)고객 엔터티에 회원id,패스워드,이름,주소,전화번호 관계- 엔터티는 다른 엔터티와 최소한 한 개 이상의 관계가 있어야한다. ex)고객은 계좌를 개설한다. 업무- 엔터티는 업무에서 관리되어야하는 집합이다. 릴레이션과 테이블, 인스턴스 릴레이션과 테이블은 같은 의미라고 해석하면 된다. 릴레이션에 기본키 및 제약조건을 설정하면 테이블이 된다. 단 Relationship은 릴레이션 간의 관계를 의미한다. 인스턴스는 릴레이션이 가질 수 있는 값을 의미한다. 간단하게 생각하면 행의 수를 의미한다.(인덱스) 엔터티의 종류 엔터티의 종류는 유형과 무형에 따른 종류,엔터티가 발생하는 시점에 따른 종류로 나누어 진다. 엔터티를 유형과 무형으로 분류하는 기준은 물리적 형태의 존재여부다 . 유형과 무형에 따른 엔터티 종류 유형 엔터티:업무에서 도출되며 지속적으로 사용되는 엔터티이다. ex)고객,강사,사원 등 개념 엔터티:유형 엔터티는 물리적형태가 있지만, 개념 엔터티는 물리적 형태가 없다. ex)거래소,종목,코스닥 종목 사건 엔터티:비즈니스 프로세스를 실행하면서 생성되는 엔터티이다. ex)주문,체결,취소주문,수수료 청구 등 발생 시점에 따른 엔터티종류 기본엔터티: 키 엔터티라고도 한다, 다른 엔터티로부터 영향을 받지 않고 독립적으로 생성되는 엔터티이다. 중심엔터티:기본 엔터티와 행위 엔터티 간의 중간에 있는 것이다. 즉 기본엔터티로부터 발생되고 , 행위 엔터티를 생성하는 것이다. ex)계좌,주문,취소,체결 등 행위 엔터티:2개 이상의 엔터티로 부터 발생된다. ex)주문이력,체결이력 등 속성 속성이라는 것은 업무에서 필요한 정보인 엔터티가 가지는 항목이다. 속성은 더 이상 분리되지 않는 단위로, 업무에 필요한 데이터를 저장할 수 있다. 인스턴스의 구성요소이고 의미적으로 더 이상 분해되지 않는다. 속성의 특징과 종류(1) 속성의 특징 속성은 업무에서 관리되는 정보이다. 속성은 하나의 값만 가진다. 주식별자에게 함수적으로 종속된다, 즉 기본키가 변경되면 속성의 값도 변경된다는 것이다. (2) 속성의 종류 분해 여부에 다른 속성의 종류 단일속성:하나의 의미로 구성된 것으로 회원 id , 이름 등이다. 복합속성: 여러 개의 의미가 있는 것으로 대표적으로 주소가 있다,주소는 시,군,동 등으로 분해될 수 있다. 다중값 속성- 속성에 여러 개의 값을 가질 수 있는것으로 예를 들어 상품 리스트가 있다.,다중값 속성은 엔터티로 분해된다. 특성에 따른 속성의종류 기본속성:비즈니스 프로세스에서 도출되는 본래의 속성이다. ex)회원id,이름,계좌번호,주문 일자 등 설계속성: 데이터 모델링 과정에서 발생되는 속성이다. , 유일한 값을 부여한다 ex)상품코드,지점코드 등 파생속성:다른 속성에 의해서 만들어지는속성이다 도메인 도메인은 속성이 가질 수 있는 값의 범위이다. ex)성별이라는 속성의 도메인은 남자와 여자이다. 관계 관계는 엔터티 간의 관련성을 의미하며 존재관계와 행위관계로 분류된다. 존재관계는 두 개의 엔터티가 존재 여부의 관계가 있는 것이고,행위 관계는 두 개의 엔터티가 어떤 행위에 의한 관련성이 있는것이다. 관계의 종류(1) 존재관계 존재 관계는 엔터티 간의 상태를 의미한다. 예를들어 고객이 은행에 회원가입을 하면, 관리점이 할당되고, 그 할당된 관리점에서 고객을 관리한다. (2) 행위관계 행위 관계는 엔터티 간에 어떤 행위가 있는 것으로, 계좌를 사용해서 주문을 발주하는 관계가 만들어진다. 예를들어 증권회사는 계좌를 개설하고 주문을 발주하는 것이다 관계차수 관계 차수는 두 개의 엔터티 간에 관계에서 참여하는 수를 의미한다. 예를들어 한명의 고객은 여러 개의 계좌를 개설할 수 있다. 이러한 경우는 1대N관계가 된다. 1대1 관계 1대1 관계는 완전 1대1관계와 선택적 1대1 관계가 있다. 다음의 예는 선택적 1대1 관계를 표현한것이다. 한명의 고객은 하나의 고객등급이부여되거나 고객 등급이 없을수도 있다. 완전 1대1:하나의 엔터티에 관계되는 엔터티의 관계가 하나인 경우로,반드시 존재해야한다. 선택적 1대1: 하나의 엔터티에 관계되는 엔터티의 관계가 하나이거나 없을 수도 있다. 1대 N관계 1대N 관계는 엔터티에 행이 하나 있을 때 다른 엔터티의 값이 여러 개 있는 관계이다. 예를들어 고객은 여러개의 계좌를 가질 수 있다. M대N관계 M대N관계는 두 개 엔터티가 서로 여러개의 관계를 가지고 있는 것이다. 예를들어 한명의 학생이 여러개의 과목을 수강할 수 있다. 바낻로 한 개의 과목은 여러명의 학생이 수강한다, 그래서 M대N관계가 발생한다. 관계형 데이터베이스에서 M대N관계의 조인은 카테시안 곱이 발생한다. 그래서 M대N관계를 1대N, N대 1로 해소해야한다. 카테시안 곱 (곱집합) 각 릴레이션에 존재하는 모든 데이터를 조합하여 연산하는 것을 말한다. 필수적 관계와 선택적관계 필수적 관계: 반드시 하나가 있어야 하는 관계이다. EX) 고객이 반드시 있어야 계좌를 개설할 수 있다. 선택적 관계: 1.없을수도 있는 관계이다 2. 고객은 있지만, 계좌가 없을 수도 있다면 선택적 관계가 된다. 식별관계와 비식별 관계식별관계 고객과 계좌 엔터티에서 고객은 독립적으로 존재할 수 있는 강한개체 이다. 강한 개체는 어떤 다른 엔터티에게 의존하지 않고 독립적으로 존재한다. 강한 개체는 다른 엔터티와 관계를 가질 때 다른 엔터티에게 기본키를 공유한다. 강한 개체는 식별관계로 표현된다. 즉, 식별 관계란 고객 엔터티의 기본키인 회원 ID를 계좌 엔터티의 기본키의 하나로 공유하는 것이다. 강한 개체의 기본키 값이 변경되면 식별관계(기본키를 공유받은)에 있는 엔터티의 값도 변경 된다. 여기서 계좌 엔터티는 약한 개체가 된다. 비식별 관계 비식별관계는 강한 개체의 기본키를 다른 엔터티의 기본키가 아닌 일반 칼럼으로 관계를 가지는 것이다. 예를 들어 관리점 엔터티의 기본키는 지점코드이고 괙 엔터티와 비식별 관계를 가지고 있다. 즉, 지점코드는 고객 엔터티의 기본키가 아닌 일반칼럼으로 참조된다. 비식별 관계는 점선으로 표현한다. 엔터티 식별자주식별자 (기본키, Primary key) 최소성:주식별자는 최소성을 만족하는 키이다.→ 키를 구성하는 속성들 중 꼭 필요한 최소한의 속성들로만 키를 구성. 대표성:주식별자는 엔터티를 대표할 수 있어야 한다. 유일성:주식별자는 엔터티의 인스턴스를 유일하게 식별한다. 불변성:주식별자는 자주 변경되지 않아야 한다. 키의 종류 기본키:후보키 중에서 엔터티를 대표할 수 있는 키이다. 후보키:후보키는 최소성과 유일성을 만족하는 키이다.(최소성 o 유일성 o) 슈퍼키:슈퍼키는 유일성은 만족하지만 최소성을 만족하지 않는 키이다. (유일성 o 최소성 x) 대체키:대체키는 여러 개의 후보키 중에서 기본키를 선정하고 남은 키이다. ( 기본키를 선정하고 남은 키) 외래키:하나 혹은 다수의 다른 테이블의 기본 키 필드를 가리키는 것으로 참조 무결성을 확인하기 위해 사용되는 키이다. , 즉 허용된 데이터값만 데이터베이스에 저장하기 위해서 사용한다. cf) 참조무결성: 하나의 기본키를 외래키로 공유하고 있다면 기본키의 값이 달라지면 외래키의 값도 같이 변하는 것, 식별자의 종류 식별자는 대표성, 생성여부,속성의 수 , 대체 여부로 분류된다. (1) 식별자의 대표성 주식별자는 엔터티를 대표할 수 있는 식별자이다. 예를들어 회원 id 는 고객 엔터티에 주식별자가 된다. 주식별자-유일성과 최소성을 만족하면서 엔터티를 대표하는 식별자 이다. -다른 엔터티와 참조 관계로 연결될 수 있다. 보조식별자- 유일성과 최소성은 만족하지만 대표성을 만족하지 못하는 식별자이다. (2)생성 여부 내부 식별자-내부식별자는 엔터티 내부에서 스스로 생성되는 식별자이다. ex)부서코드,주문번호,종목코드 등 외부 식별자-다른 엔터티와의 관계로 인하여 만들어지는 식별자이다. ex)계좌 엔터티에 회원 id (3)속성의 수 단일 식별자- 하나의 속성으로 구성된다 ex)고객 엔터티에 회원id 복합 식별자-두 개 이상의 속성으로 구성된다. (4)대체 여부 본질 식별자 - 비즈니스 프로세스에서 만들어지는 식별자이다. 인조 식별자- 인위적으로 만들어지는 식별자이다. 인조 식별자 인조 식별자는 후보 식별자 중에서 주식별자로 선정할 것이 없거나, 주식별자가 너무 많은 칼럼으로 되어 있는경우에 사용된다 ,즉 순서번호를 사용해서 식별자를 만드는것이다. 정규화 정규화는 데이터의 일관성,최소한의 데이터 중복, 최대한의 데이터 유연성을 위한 방법이며 데이터를 분해하는 과정이다 정규화는 데이터 중복을 제거하고 데이터 모델의 독립성을 확보하기 위한 방법이다. 정규화는 테이블을 분해해서 데이터 중복을 제거하기 때문에 데이터 모델의 유연성을 높힌다. 정규화를 수행하면 비즈니스에 변화가 발생하여도 데이터 모델의 변경을 최소화할 수 있다. 정규화는 제1정규화부터 제5정규화까지 있지만, 실질적으로는 제3정규화까지만 수행한다. 위의 테이블은 정규화를 수행하지 않은 것으로, 부서테이블과 직원 테이블을 하나로 합쳐 둔 것이다. 만약 위의 테이블에서 새로운 직원이 추가되는 경우 부서 정보가 없으면 부서코드를 임의의 값으로 넣어야한다. 즉, 불필요한 정보가 같이 추가되는 것이다. 또한 새로운 “총무부”가 추가되어야 할 경우 사원 정보가 없기 때문에 임의의 값으로 사원번호를 입력하거나 추가할 수 없게 된다. 이러한 문제를 이상현상 이라고한다. 위와 같은 문제를 해결하기 위해서는 테이블을 분해해야한다. 정규화된 모델은 테이블이 분해된다. 테이블이 분해되면 직원테이블과 부서테이블 간에 부서코드로 조인을 수행하여 하나의 합집합으로 만들수 있다. 정규화를 수행하면 불필요한 데이터를 입력하지 않아도 되기 때문에 중복데이터가 제거된다. 함수적 종속성 제1 정규화,제2 정규화,제3 정규화 제 1 정규화:각각의 컬럼들을 원자화 하여라 ( 값들을 하나씩 가지게 하여라)→1.속성의 원자성을 확보한다 2.기본키를 설정한다 제2 정규화 기본키가 2개 이상의 속성으로 이루어진 경우, 부분 함수 종속성을 제거(분해) 한다. 같은 테이블 안에서 부분함수적 종속성이 발생하면 안된다. 이를 제거해야한다 → 동시에 중복도 제거됨,부분함수적 종속성이 발생하면 안되는거지 하나의 테이블 안에서 프라이머리 키에 의해서 함수의 종속성은 발생해야하는 것이다. 제3 정규화 기본키를 제외한 칼럼 간에 종속성을 제거한다. 즉, 이행 함수 종속성을 제거한다. 정규화의 성능1.정규화의 문제점 정규화는 데이터 조회 시에 조인을 유발하기 때문에 cpu와 메모리를 많이 사용한다. 정규화의 문제점을 해결하기 위해서 반정규화를 하여 하나의 테이블에 저장한다면 조인을 통한 성능 저하는 해결될 것이다. 하지만 반정규화로 너무 많은 칼럼이 추가되면 한 개 행의 크기가 데이터 베이스 관리 시스템의 입출력 단위인 블록의 크기를 넘어서게 된다. 그렇게 되면 한 개의 행을 읽기 위해서 여러 개의 블록을 읽어야 한다. 한행을 읽기 위해서 여러 개의 블록을 읽게 되면 디스크 입출력이 증가하기 때문에 성능이 떨어지게된다. 반 정규화는 이러한 문제점을 유발할수 있다. 반정규화 데이터베이스 성능 향상을 위하여, 데이터 중복을 허용하고 조인을 줄이는 데이터베이스 성능 향상 방법이다. 반정규화는 조회 속도를 향상하지만, 데이터 모델의 유연성은 낮아진다. 반정규화를 수행하는 경우 정규화를 충실하면, 종속성 ,활용성은 향상되지만 수행속도가 느려지는 경우 다량의 범위를 자주 처리해야 하는 경우 특정 범위의 데이터만 자주 처리하는경우 요약&#x2F;집계 정보가 자주 요구되는 경우 반정규화 절차 대상 조사 및 검토:데이터 처리 범위, 통계성 등을 확인해서 반정규화 대상을 조사한다. 다른 방법검토:반정규화를 수행하기 전에 다른 방법이 있는지 검토한다, 예를들어 클러스터링 뷰,인덱스 튜닝,응용 프로그램,파티션 등을 검토한다. 반정규화 수행:테이블,속성,관계 등을 반정규화 한다 반정규화 기법(1) 계산된 칼럼 추가 배치 프로그램으로 총판매액,평균잔고,계좌평가 등을 미리 계산하고, 그 결과를 특정 칼럼에 추가한다. (2)테이블 수직 분할 하나의 테이블을 두 개 이상의 테이블로 분할한다. 즉,칼럼을 분할하여 새로운 테이블을 만드는 것이다. (3)테이블 수평 분할 하나의 테이블에 있는 값을 기준으로 테이블을 분할하는 방법이다. 파티션 기법 데이터베이스에서 파티션을 사용하여 테이블을 분할할 수 있다. 파티션을 사용하면 논리적으로는 하나의 테이블이지만, 여러 개의 데이터 파일에 분산되어 저장한다. Range partition:데이터 값의 범위를 기준으로 파티션을 수행한다 list partition:특정한 값을 지정하여 파티션을 수행한다 hash partition:해시 함수를 적용하여 파티션을 수행한다. Composite Partiton:범위와 해시를 복합적으로 사용하여 파티션을 수행한다. 파티션 테이블의 장점 데이터 조회 시에 엑세스 범위가 줄어들기 때문에 성능이 향상된다. 데이터가 분할되어 있기 때문에 input&#x2F;output 성능이 향상된다. 각 파티션을 독립적으로 백업 및 복구가 가능하다 (4) 테이블 병합 1대1관계의 테이블을 하나의 테이블로 병합해서 성능을 향상시킨다. 1대N 관계의 테이블을 병합하여 성능을 향상시킨다. 하지만 많은 양의 데이터 중복이 발생한다. 슈퍼 타입과 서브타입 관계가 발생하면 테이블 통합하여 성능을 향상시킨다. SUPER TYPE 과 SUB TYPE 고객 엔터티는 개인고객과 법인고객으로 분류된다. 이때 고객 엔티티는 슈퍼타입이고, 개인고객과 법인고객은 서브타입이 된다 (대분류 소분류 관계) 즉, 부모와 자식 간의 관계가 나타난다, 슈퍼타입과 서브 타입의 관계는 배타적 관계와 포괄적 관계가 있는데 , 베타적 관계는 고객이 개인고객이거나 법인고객인 경우를 의미한다. 포괄적 관계는 고객이 개인고객일 수도 있고 법인 고객일 수도 있다. 슈퍼 타입 및 서브 타입 변환 방법 ONE TO ONE TYPE -슈펴타입과 서브타입을 개별 테이블로 도출한다. -테이블의 수가 많아서 조인이 많이 발생하고 관리가 어렵다. Plus type -슈퍼타입과 서브 타입 테이블로 도출한다 -조인이 발생하고 관리가 어렵다 single type-슈퍼 타입과 서브타입을 하나의 테이블로 도출한다. -조인 성능이 좋고 관리가 편리하지만, 입출력 성능이 나쁘다. 분산 데이터베이스데이터베이스 구조 데이터베이스 시스템 구축 시에 한 대의 물리적 시스템에 데이터베이스 관리 시스템을 설치하고 여러명의 사용자가 데이터베이스 관리 시스템에 접속하여 데이터베이스를 사용하는 구조를 중앙집중형 데이터베이스 라고한다 또한 물리적으로 떨어진 데이터베이스에 네트워크로 연결하여 단일 데이터베이스 이미지를 보여주고 분산된 작업처리를 수행하는 데이터베이스를 분산 데이터베이스 라고 한다 분산 데이터베이스의 투명성 분산 데이터베이스를 사용하는 고객은 시스템이 네트워크로 분산되어 있는지의 여부를 인식하지 못하면서, 자신만의 데이터베이스를 사용하는 것처럼 사용할 수 있다. 이처럼, 데이터베이스는 투명성을 제공해야 한다. 투명성은 분산 데이터베이스에서 중요한 요소이며, 투명성의 종류에는 분할,위치,지역사상,중복,장애 및 병행 투명성이 있다. 분산 데이터베이스의 투명성 종류1.분할투명성: -고객은 하나의 논리적 릴레이션이 여러 단면으로 분할되어 각 단편의 사본이 여러 시스템에 저장되어 있음을 인식할 필요가 없다 2.위치투명성:-고객이 사용하려는 데이터의 저장 장소를 명시할 필요가 없다 -고객은 데이터가 어느 위치에 있더라도 동일한 명령을 사용하여 데이터에 접근할 수 있어야한다. 3.지역사상 투명성 -지역 DBMS와 물적 데이터베이스 사이의 사상이 보장됨에 따라 각 지역 시스템 이름과 무관한 이름이 사용 가능하다 4.중복투명성-데이터베이스 객체가 여러 시스템에 중복되어 존재함에도 고객과는 무관하게 데이터의 일관성이 유지된다 5.장애투명성-데이터베이스가 분산되어 있는 각 지역의 시스템이나 통신망에 이상이 발생해도, 데이터의 무결성은 보장된다. 6.병행투명성 -여러 고객의 응용 프로그램이 동시에 분산 데이터베이스에 대한 트랜잭션을 수행하는 경우에도 결과에 이상이 없다 분산 데이터베이스 설계방식 분산 데이터베이스의 구축 방법에는 상향식 설계 방식과 하향식 설계 방식 2가지가 있다. (1) 상향식 설계방식 지역 스키마 작성 후 전역스키마를 작성하여 분산 데이터베이스를 구축한다. (2)하향식 설계방식 전역 스키마 작성 후 해당 지역 사상 스키마를 작성하여 분산 데이터베이스를 구축한다. 분산 데이터베이스를 하향식 접근 방식으로 구축한다는 것은 기업 전체의 전사 데이터 모델을 수렴하여 전역 스키마를 생성하고, 그 다음 각 지역별로 지역 스키마를 생성하여 분산 데이터베이스를 구축 하는 것이다. 상향식 접근 방식은 지역별로 데이터베이스를 구축한 후에 전역 스키마로 통합하는 것이다. 분산 데이터베이스를 구축하거나 운영할 때 동일한 데이터베이스 관리 시스템으로 분산 데이터베이스를 구축하는 것은 크게 어렵지 않다. 하지만 기업에 여러 종류의 데이터베이스 관리 시스템이 있으면 이기종 데이터베이스 관리시스템으로 연동해야 한다. 이기종 데이터베이스 시스템으로 연동하기 위해서는 데이터베이스 미들웨어 (ODBC,JDBC)를 사용해야 한다. 분산 데이터베이스 장점과 단점 장점:1.데이터베이스의 신뢰성과 가용성이 높다. 2.분산 데이터베이스가 병렬 처리를 수행하기 때문에 빠른 응답이 가능하다. 3.분산 데이터베이스를 추가하여 시스템 용량 확장이 쉽다 단점: 1.데이터베이스가 여러 네트워크를 통해서 분리되어 있기 때문에 관리와 통제가 어렵다 2.보안관리가 어렵다. 3.데이터 무결성 관리가 어렵다 4.데이터베이스 설계가 복잡하다. 관계형 데이터베이스(1) 관계형 데이터베이스의 등장 관계형 데이터베이스는 릴레이션과 릴레이션의 조인연산을 통해서 합집합,교집합,차집합 등을 만들 수 있다. 현재 기업에서 가장 많이 사용하는 데이터베이스로 Oracle,MS-SQL,MYSQL,SYBASE 등의 다양한 데이터베이스 관리 시스템이 있다 데이터베이스와 데이터베이스 관리 시스템의 차이점 데이터베이스는 데이터를 어떠한 형태의 자료구조로 사용하느냐에 따라서 나누어진다. 데이터베이스의 종류는 계층형,네트워크형 데이터베이스, 관계형 데이터베으 등이 있다. 계층형 데이터베이스는 트리 형태의 자료구조에 데이터를 저장하고 관리하며, 네트워크는 오너와 멤버 형태로 데이터를 저장한다 계층형 데이터베이스는 1대 N 관계를 표현한다. 네트워크 데이터 베이스는 1대N과 함계 M대N 표현도 가능하다 관계형 데이터베이스는 릴레이션에 데이터를 저장하고 관리한다. 관계형 데이터베이스는 릴레이션을 사용해서 집합 연산과 관계 연산을 할 수 있다. 데이터베이스 관리 시스템은 계층형 데이터베이스, 네트워크 데이터베이스,관계형 데이터베이스 등을 관리하기 위한 소프트웨어를 의미하며, 일명 DBMS라고 한다. 관계형 데이터베이스 집합연산과 관계연산 관계형 데이터베이스의 특징은 릴레이션을 사용해서 집합 연산과 관계 연산을 할 수 있다. 집합연산합집합-두 개의 릴레이션을 하나로 합하는 것이다. 차집합-본래 릴레이션에는 존재하고 다른 릴레이션에는 존재하지 않는 것을 조회한다. 교집합-두 개의 릴레이션 간에 공통된 것을 조회한다 곱집합-각 릴레이션에 존재하는 모든 데이터를 조합하여 연산한다. 관계연산선택연산:릴레이션에서 조건에 맞는 행(튜플)만을 조회한다 투영연산:릴레이션에 조건에 맞는 속성만을 조회한다. 결합연산:여러 릴레이션의 공통된 속성을 사용해서 새로운 릴레이션을 만들어 낸다. 나누기연산:기준 릴레이션에서 나누는 릴레이션이 가지고 있는 속성과 동일한 값을 가지는 행을 추출하고 나누는 릴레이션의 속성을 삭제한 후 중복된 행을 제거하는 연산이다. 테이블의 구조 기본키는 하나의 테이블에서 유일성과 최소성, Not Null을 만족하면서 해당 테이블을 대표하는 것이다. 테이블은 행과 칼럼으로 구성된다. 그 중에서 행은 하나의 테이블에 저장되는 값으로 튜플 이라고 한다. 칼럼은 어떤 데이터를 저장하기 위한 필드로 속성 이라고도 한다. 외래키는 다른 테이블의 기본키를 참조 하는 칼럼이다. 외래키는 관계연산 중에서 결합연산(join)을 하기 위해서 사용한다 SQL 종류 SQL은 관계형 데이터베이스에 대해서 데이터의 구조를 정의, 데이터 조작, 데이터 제어 등을 할 수 있는 절차형 언어이다. 관계형 데이터베이스는 데이터베이스를 연결하고 SQL문을 사용하여 데이터베이스를 누구나 쉽게 사용할 수 있도록 한다. SQL은 ANSI&#x2F;ISO 표준을 준수하기 때문에 데이터베이스 관리 시스템이 변경되어도 그대로 사용할 수 있다. SQL 표준 ANSI&#x2F;ISO SQL 표준:INNER JOIN, NATURAL JOIN,USING 조건, ON 조건절을 사용한다 ANSI&#x2F;ISO SQL3 표준:DBMS 벤더별로 차이가 있었던 SQL을 표준화하여 제정했다. SQL 종류 SQL은 데이터 정의, 데이터조작,데이터 제어 등의 기능을 지원한다 (1) DDL- 관계형 데이터베이스의 구조를 정의하는 언어이다. - CREATE,ALTER,DROP,RENAME,TRUNCATE 문이 있다. (2)DML-테이블에서 데이터를 입력,수정,삭제,조회한다. - INSERT,UPDATE,DELETE,SELECT 문이 있다. (3)DCL- 데이터베이스 사용자에게 권한을 부여하거나 회수한다. - GRANT,REBOKE문이 있다. (4)TCL-트랜잭션을 제어하는 명령어이다 - COMMIT,ROLLBACK,SAVEPOINT DDL문은 데이터베이스 테이블을 생성하거나 변경,삭제하는 것으로 데이터를 저장할 구조를 정의하는 언어이다 DML은 데이터 구조가 DDL로 정의되면 해당 데이터 구조에 데이터를 입력하거나 수정,삭제,조회할 수 있다. DCL은 DDL로 정의된 구조에 어떤 사용자가 접근할 수 있는지 권한을 부여하는 것이다. 작업의 순서를 보면 데이터베이스의 사용자에게 권한을 부여하고 , 권한이 부여되면 DDL로 데이터 구조를 정의한다. 데이터 구조가 정의되면 데이터를 입력한 후에 개발자 및 사용자가 그 데이터를 조회하는 것이다. 트랜잭션 트랜잭션은 데이터베이스의 작업을 처리하는 단위이다. 트랜잭션의 특성원자성 - 트랜잭션은 데이터베이스 연산의 전부가 실행되거나 전혀 실행되지 않아야 한다. -즉, 트랜잭션의 처리가 완전히 끝나지 않았을 경우는 실행되지 않은 상태와 같아야 한다. 일관성-트랜잭션 실행 결과로 데이터베이스의 상태가 모순되지 않아야 한다. -트랜잭션 실행 후에도 일관성이 유지되어야 한다 고립성-트랜잭션 실행 중에 생성하는 연산의 중간결과는 다른 트랜잭션이 접근할 수 없다. -즉, 부분적인 실행 결과를 다른 트랜잭션이 볼 수 없다. 영속성-트랜잭션이 그 실행을 성공적으로 완료하면 그 결과는 영구적 보장이 되어야 한다. SQL문의 실행 순서 개발자가 작성한 SQL문 (DDL,DML,DCL 등) 3단계를 걸쳐서 실행된다. SQL 문의 문법을 검사하고 구문 분석을 한다. 구문 분석 이후에 SQL을 실행한다. SQL이 실행되면 데이터를 인출하게 된다. SQL 실행순서 파싱-SQL 문의 문법을 확인하고 구문 분석한다. -구문 분석한 SQL문은 LIBRARY CACHE에 저장한다 실행-옵티마이저가 수립한 실행 계획에 따라 SQL을 실행한다. 인출-데이터를 읽어서 전송한다 DDL(Data Definition Language)Create Table - 새로운 테이블을 생성한다. - 테이블을 생성할때 기본키,외래키,제약사항 등을 설정할 수 있다. Alter Table - 생성된 테이블을 변경한다. - 칼럼을 추가하거나 변경,삭제할 수 있다. - 기본키를 설정하거나,외래키를 설정할 수있다. drop Table- 해당 테이블을 삭제한다. - 테이블의 데이터 구조뿐만 아니라 저장된 데이터도 모두 삭제된다. 기본적인 테이블 생성 number는 칼럼의 데이터 타입을 숫자형 타입으로, varchar2는 가변 길이 문자열로 지정할 때 사용한다. char은 칼럼의 데이터 타입을 고정된 크기의 문자로 지정할 때, date는 날짜형 타입으로 지정할때 , 사용된다 (2) 제약조건 사용 기본키,외래키,기본값,not null 등은 테이블 생성할때 지정할 수 있다. 위의 예를 보면 “constraint” 를 사용하여 기본키(empno)와 기본키의 이름(emppk)를 지정할수 있다. 만약 위의 예에서 두 개의 기본키를 지정하고자 한다면 “constraint emppk primary key(empno,ename)” 으로 지정하면 된다. sal 칼럼은 number(10,2)로 지정했다. 이것은 소수점 둘째자리까지 저장하게 된다. oracle 데이터베이스에서 “sysdate” 는 오늘의 날짜를 조회한다. 이를 default 옵션을 사용해서 오늘 날짜를 기본값으로 지정할 수 있다. 외래키를 지정하려면, 먼저 마스터 테이블이 생성되어야 한다. 즉, 사원과 부서 테이블에서는 부서가 마스터 테이블이 된다. 즉, 사원 테이블이 부서 테이블의 deptno를 참조해야 하는 것이다. 그리고 EMP 테이블을 생성할 때 constraint를 사용하여 외래키 이름인 “deptfk”를 입력 후 외래키를 생성한다. (3) 테이블 생성시 CASCADE 사용 테이블을 생성할때 CASCADE 옵션을 사용할 수 있다. CASCADE 옵션은 참조관계(기본키와 외래키 관계) 가 있을 경우 참조되는 데이터를 자동으로 반영할 수 있는 것이다. 먼저, 마스터 테이블을 생성한다. 즉 DEPT 테이블을 생성하고 데이터를 입력한다 그 다음 EMP 테이블을 생성하고 데이터를 입력한다. 단, EMP 테이블을 생성할때, ON DELETE CASCADE 옵션을 사용한다. EMP 테이블을 생성하고 데이터 두 개를 입력한다. 위의 예제를 보면 dept 테이블에서 deptno가 1004번인 인사팀을 삭제했다. 그리고 emp 테이블의 데이터를 조회한 결과 deptno ‘1000’번 이었던 임베스트 데이터도 자동으로 삭제된 것을 알 수 있다. 즉,ON DELETE CASCADE 옵션은 자신이 참조하고 있는 테이블의 데이터가 삭제 되면 자동으로 자신도 삭제되는 옵션이다. ON DELETE CASCADE 옵션을 사용하면 참조 무결성을 준수할 수 있다. 참조무결성이란 마스터 테이블에는 해당 부서번호가 없는데 슬레이브 테이블에는 해당 부서번호가 있는 경우 참조 무결성 위배로 볼 수 있다. 테이블 변경 ALTER TABLE문을 통해 테이블 변경을 할 수 있으며, 테이블명 변경, 칼럼추가,변경,삭제 등을 할 수 있다. (1) 테이블명 변경 테이블명 변경은 ALTER TABLE ~ RENAME TO 문을 사용하면 된다 (2) 칼럼 추가 생성된 EMP 테이블에 ALTER TABLE ~ ADD 문을 사용해서 칼럼을 추가한다. (3) 컬럼변경 칼럼의 변경은 ALTER TABLE ~ MODIFY문을 사용하면 된다. 칼럼 변경을 통해 데이터 타입을 변경하거나 데이터의 길이를 변경할 수 있다. 칼럼을 변경할 때 제약조건을 설정할 수도 있다. 칼럼의 데이터 타입을 변경할 때 기존 데이터가 있는 경우 에러가 발생한다. 예를 들어 숫자 타입이고, 숫자 데이터가 저장되어 있는데 문자형 데이터 타입으로 변경하면 에러가 발생하는 것이다. (4)칼럼 삭제 칼럼에 대한 삭제는 ALTER TABLE ~ DROP COLUMN 문으로 삭제한다. (5) 칼럼명 변경 칼럼병 변경은 ALTER TABLE ~ RENAME COLUMN ~TO 문으로 변경 할수 있다. 테이블 삭제 테이블 삭제는 DROP Table문을 사용해서 삭제할 수 있다. DROP TABLE은 테이블의 구조와 데이터를 모두 삭제한다 DROP TABLE 에서 “CASCADE CONSTRAINT” 옵션을 사용할 수 있다. “CASCADE CONSTRAINT” 옵션은 해당 테이블의 데이터를 외래키로 참조한 슬레이브 테이블과 관련된 제약사항도 삭제할 때 사용된다 . DROP TABLE EMP CASCADE CONSTRAINT; 뷰(VIEW) 생성과 삭제 뷰란 테이블로부터 유도된 가상의 테이블이다. 실제 데이터를 가지고 있지 않고, 테이블을 참조해서 원하는 칼럼만을 조회할 수 있게 한다. 뷰는 데이터 딕셔너리에 SQL문 형태로 저장하되 실행시에 참조된다. 뷰의 특징 참조한 테이블이 변경되면 뷰도 변경된다. 뷰의 검색은 참조한 테이블과 동일하게 할 수 있지만, 뷰에 대한 입력, 수정 ,삭제에는 제약이 있다 특정 칼럼만 조회시켜서 보안성을 향상 시킨다 한번 생성된 뷰는 변경할 수 없고 변경을 원하면 삭제 후 재생성해야 한다. ALTER 문을 사용해서 뷰를 변경할 수 없다. 뷰를 생성할 때 CREATE VIEW문을 사용하여 이때 참조할 테이블은 SELECT 문으로 지정한다. 뷰의 삭제는 ‘DROP VIEW’ 를 사용한다. 뷰를 삭제했다고 해서 참조했던 테이블이 삭제되지는 않는다 뷰의 장점과 단점장점:1.특정 칼럼만 조회할 수 있기 때문에 보안기능이 있다. 2.데이터 관리가 간단하다 [3.SELECT](http://3.SELECT) 문이 간단해진다. 4.하나의 테이블에 여러개의 뷰를 생성할 수 있다. 단점: 1.뷰는 독자적인 인덱스를 만들 수 없다. 2.삽입,수정삭제 연산이 제약된다 3.데이터구조를 변경할수는 없다 DML(DATA Manipulation Language)INSERT문(1) INSERT 문 INSERT문은 테이블에 데이터를 입력하는 DML문이다. INSERT문INSERT INTO table (column1,column2) values (… , ….) EMP 테이블에 데이터를 삽입하려면 테이블명,칼럼명,데이터 순으로 입력하면 된다. SELECT 문 SELECT문을 사용하여 데이터를 조회해서 해당 테이블에 바로 삽입할 수 있다. 단 입력되는 테이블은 사전에 생성되어 있어야 한다. 123INSERT INTO DEPT_TEST SELECT * FROM DEPT;DEPT 테이블의 모든 데이터를 조회해서 DEPT_TEST 에 넣는다. (3) NOLOGGING 사용 데이터 베이스에 데이터를 입력하면 로그파일에 그 정보를 기록한다 check point라는 이벤트가 발생하면 로그파일의 데이터를 데이터 파일에 저장한다. NoLogging 옵션은 로그파일의 기록을 최소화시켜서 입력시 성능을 향상시키는 방법이다. Nologging 옵션은 Buffer Cache라는 메모리 영역을 생략하고 기록한다. UPDATE 문 입력된 데이터의 값을 수정하려면 UPDATE 문을 사용한다. UPDATE문을 사용하여 원하는 조건으로 데이터를 검색해서 해당 데이터를 수정할 수 있다. 만약,UPDATE문에 조건문을 입력하지 않으면 모든 데이터가 수정되므로 유의해야 한다. 123UPDATE EMP SET ENAME=&#x27;조조&#x27; WHERE EMPNO=100; UPDATE 문에서 주의사항은 데이터를 수정할 때 조건절에서 검색되는 행 수만큼 수정된다는 것이다. 앞의 예이서 DEPTNO&#x3D;1111 인 사람이 두명이라면 두명 모두 조조로 수정된다. DELETE 문 DELETE문은 원하는 조건을 검색해서 해당되는 행을 삭제한다. DELETE문에 조건문을 입력하지 않으면 모든 데이터가 삭제된다. 즉, 테이블에 있는 모든 데이터가 삭제되는 것이다. DELETE문으로 데이터를 삭제한다고 해서 테이블의 용량이 초기화 되지는 않는다. 만약 위의 예에서 WHERE절을 입력하지 않으면 EMP 테이블의 모든 데이터가 삭제 된다. 테이블 용량이 초기화 되지 않는다는 의미 ORACLE 데이터베이스는 저장공간을 할당할때 저 EXTENT 단위로 할당한다. 테이블에 데이터가 입력되면 EXTENT에 저장하게 된다. 만약 EXTENT의 크기가 MAX_EXTENTS를 넘어서게 되면 용량 초과 오류가 발생하게된다. 즉, 최대로 저장할 수 있는 공간의 의미를 가지고 있다. DELETE문으로 데이터를 삭제하면 용량이 감소할 것으로 생각하는데,DELETE문은 삭제 여부만 표시하고 용량은 초기화되지 않는다. 테이블의 모든 데이터 삭제DELETE FROM 테이블명; 테이블의 모든 데이터를 삭제한다. 데이터가 삭제되어도 테이블의 용량은 감소하지않는다 TRUNCATE TABLE 테이블명 ; 테이블의 모든 데이터를 삭제한다. 데이터가 삭제되면 테이블의 용량은 초기화 된다. SELECT문 사용 테이블에 입력된 데이터를 조회하기 위해서 SELECT문을 사용한다. SELECT문은 특정 칼럼이나 특정 행만을 조회한다. SELECT 칼럼 지정사용예제 SELECT EMPNO,ENAME FROM EMP; ⇒ EMP 테이블의 모든 행에서 EMPNO와 ENAME 칼럼만 출력한다. SELECT * FROM EMP; ⇒ EMP 테이블의 모든 칼럼과 모든 행을 조회한다. SELECT ENAME || ‘님’ FROM EMP; ⇒ EMP 테이블의 모든 행에서 ENAME 칼럼을 조회한다. 단,ENAME 칼럼 뒤에 ‘님’ 이라는 문자를 결합한다. ORDER BY를 사용한 정렬 SELECT문을 사용할 때 ORDER BY를 같이 사용할 수 있다 ORDER BY는 데이터를 오름차순 혹은 내림차순 으로 출력한다. ORDER BY 가 정렬을 하는 시점은 모든 실행이 끝난 후에 데이터를 출력해 주기 바로 전이다. ORDER BY는 정렬을 하기 때문에 데이터베이스 메모리를 많이 사용하게 된다. 즉, 대량의 데이터를 정렬하게 되면 정렬로 인한 성능 저하가 발생한다. 정렬을 회피하기 위해서 인덱스를 생성할 때 사용자가 원하는 형태로 오름차순 혹은 내림차순으로 설정해야한다. 특별한 지정이 없으면 ORDER BY는 오름 차순으로 정렬한다. 123SELECT * FROM EMP ORDER BY ENAME,SAL DESC;-- ENAME 은 오름차순으로 정렬되고 , SAL은 내림차순으로 정렬된다-- (3) INDEX를 사용한 정렬 회피 정렬은 ORACLE 데이터베이스에 부하를 주므로, 인덱스를 사용해서 ORDER BY를 회피할 수 있다. 위와 같이 데이터를 입력하고 SELECT문을 실행하면 EMPNO로 오름차순 정렬되어서 조회 된다. 그 이유는 EMPNO가 기본키이기 때문에 자동으로 오름차순 인덱스가 생성된다. ⇒ PRIMARY KEY에는 자동 INDEX 가 생성됨 위의 예를 보면 &#x2F;*+ INDEX_DESC(A) *&#x2F; 를 사용했다.. EMP 테이블에 생성된 인덱스를 내림차순으로 읽게 지정한 것이다. 따라서, SELECT문에 “ORDER BY EMPNO DESC” 를 사용하지 않았다. 위의 예처럼 SQL 문 사용하면 EMPNO 인덱스를 내림차순으로 읽는다. 인덱스를 스캔한 후에 해당 EMPNO의 값을 가지고 테이블의 데이터를 읽는다 테이블에서 해당 행을 찾으면 인출하여 사용자 화면에 조회된다. DISTINCT와 ALIAS DISTINCT DISTINCT 문은 칼럼명 앞에 지정하여 중복된 데이터를 한 번만 조회 하게한다. DISTINCT 를 사용하면 EMPNO 값이 중복되지 않는다. ALIAS ALIAS(별칭)은 테이블명이나 칼럼명이 너무 길어서 간략하게 할 때 사용한다. 칼럼명을 이름으로 출력,EMP 테이블명 대신에 ‘a’를 사용한다. 부정 비교 연산자 ! &#x3D; :같지 않은 것을 조회한다. ^&#x3D; :같지 않은것을 조회한다. 다중행 subquery 서브쿼리 결과가 2개 행 이상일 경우 다중행 서브쿼리라고 부릅니다.","categories":[{"name":"Development","slug":"Development","permalink":"https://kimyoungjae777.github.io/categories/Development/"},{"name":"DataBase","slug":"Development/DataBase","permalink":"https://kimyoungjae777.github.io/categories/Development/DataBase/"}],"tags":[{"name":"Development","slug":"Development","permalink":"https://kimyoungjae777.github.io/tags/Development/"},{"name":"DataBase","slug":"DataBase","permalink":"https://kimyoungjae777.github.io/tags/DataBase/"}],"author":"Young Jae Kim"},{"title":"박병창의 돈을 부르는 매매기법","slug":"박병창 돈을 부르는 매매기술 465bf7119b0748c791659ea979d5f4ff","date":"2022-08-06T00:00:00.000Z","updated":"2023-04-14T14:29:10.468Z","comments":true,"path":"2022/08/06/박병창 돈을 부르는 매매기술 465bf7119b0748c791659ea979d5f4ff/","link":"","permalink":"https://kimyoungjae777.github.io/2022/08/06/%EB%B0%95%EB%B3%91%EC%B0%BD%20%EB%8F%88%EC%9D%84%20%EB%B6%80%EB%A5%B4%EB%8A%94%20%EB%A7%A4%EB%A7%A4%EA%B8%B0%EC%88%A0%20465bf7119b0748c791659ea979d5f4ff/","excerpt":"","text":"박병창 돈을 부르는 매매기술박병창의 돈을 부르는 매매의 기술 저자:박병창 차트를 그림이 아닌, 사람들의 심리로 설명하여 그 심리에 따라 매매하는 기법을 배우는 책. ↗️패턴의 유형별 활용방법 패턴에는 헤드앤숄더,역헤드앤숄더,이중천정형 등등이 있다. 하지만 패턴에서 가장중요한 것은 패턴의 이름이 아니라 저점형성,고점형성,하락 지속과 상승 지속, 그리고 추세의 전환 이다. 하락패턴형하락삼각형 하락 삼각형은 점차 고점을 낮추면서 마치 공을 떨어뜨렸을때와 같이 반등하는 폭이 점점 작아지는 패턴이다. 초반에는 반등이 강하지만 시간이 지날수록 반등이 약해지면서,거래량도 줄어든다 헤드앤숄더형 상승 추세 중에는 고점이 계속 높아진다. 그런데 어느 시점에서 조정 후 상승할때 전고점을 상향 돌파하지 못하고 하락한다. 특히 왼쪽 어깨보다 거래량이 증가했음에도 실패할때 하락전환 확률이 커진다. 상승 3단추세를 마치고 마지막 강한 시세를 분출한 이후에 만들어진다. 이중천장형 하락패턴의 일종으로 전고를 뚫지 못하고 이중 천장을 완성시키고 하락하는 유형 역헤드엔숄더 하락추세를 마무리하고 찐 바닥을 만들고, 추세를 전환하는 패턴 →약세장에서 강세장으로 전환될때 오랫동안 추세 하락하던 주식이 상승으로 전환될때 빈번히 나타난다. 확실한 저점 확인을 위해서는 거래량 급증과 강한 반등이 있어야한다. u자형바닥과 v자형 바닥 급락후 반등에서는 v자형 바닥이 나오고 시간을 가지고 점진적인 하락을 했다면,점진적인 하락속에 많은 매물이 있기 때문에, 매물을 소화하는 과정이 필요로 하다, 그렇기때문에, 천천히 반등한다. 대칭삼각형 대칭 삼각형은 횡보성 조정이라고 볼 수 있다. 이는 상승이후 또는 하락 이후 상황에 따라 나타날수 있따. 이전에 상승 추세였다면 재차 상승을 의미 이전에 하락추세였다면 재차 하락을 의미 상승삼각형 상승삼각형은 고점은 같은 가격이거나 비슷한 가격대로, 그곳에서 저항을 받고 내려오지만 저점은 점차 높아져서 삼각형을 완성하는 유형 고점만 돌파를 한다면 급등 가능 하락삼각형 하락삼각형은 저점에서 지지하려는 매수세가 유지되고 있는데 반해, 고점이 점차 낮아지면서 하락에 대한 압박이 강해지는 유형이다. 상승쐐기형 저점과 고점이 동시에 낮아지지만 변동폭이 작아지면서 끝내 한곳에서 만나는 것을 의미한다. 하락쐐기형 상승의 강도가 점차 줄어드는 유형 하락이 예상됨.","categories":[{"name":"Book","slug":"Book","permalink":"https://kimyoungjae777.github.io/categories/Book/"}],"tags":[],"author":"Young Jae Kim"},{"title":"interceptor (인터셉터)","slug":"인터셉터(Interceptor)란 281cd9d5a8e645bdbd589725cbfd7ef2","date":"2022-08-06T00:00:00.000Z","updated":"2023-04-14T14:29:10.474Z","comments":true,"path":"2022/08/06/인터셉터(Interceptor)란 281cd9d5a8e645bdbd589725cbfd7ef2/","link":"","permalink":"https://kimyoungjae777.github.io/2022/08/06/%EC%9D%B8%ED%84%B0%EC%85%89%ED%84%B0(Interceptor)%EB%9E%80%20281cd9d5a8e645bdbd589725cbfd7ef2/","excerpt":"","text":"인터셉터(Interceptor)란?인터셉터는 이름 그대로 “무언가를 가로챈다” 라는 의미를 가집니다. 인터셉터는 컨트롤러의 url에 접근하는 과정에서 무언가를 제어할 필요가 있을때 사용됩니다. 정확히는 컨트롤러에 접근하기 전과 후로 나뉘는데, 예를들어 회원제로 이루어지는 시스템이 있다고 가정했을 때, 로그인이나 계정의 권한과 관련된 처리등을 인터셉터를 이용해서 더욱 효율적으로 처리할 수 있습니다. 스프링에서 인터셉터는 HandlerInterceptorAdapter를 상속받아 구현할 수 있습니다. 해당 클래스는 preHandle, postHandle, afterCompletion, afterConcurrentHandlingStarted 인터셉터 메소드preHandle-컨트롤러의 메서드에 매핑된 특정 URI를 호출했을 때컨트롤러에 접근하기 전에 실행되는 메서드입니다.우리는 사용자가 화면에서 어떠한 기능을 수행했을 때해당 기능과 매핑된 URI의 정보를 쉽게 파악할 수 있도록콘솔에 로그를 출력하도록 처리합니다. postHandle-컨트롤러를 경유한 다음, 화면(View)으로 결과를 전달하기 전에 실행되는 메서드입니다.우리는 요청의 끝을 알리는 로그를 콘솔에 출력하도록 처리합니다","categories":[{"name":"Development","slug":"Development","permalink":"https://kimyoungjae777.github.io/categories/Development/"},{"name":"기본개념","slug":"Development/기본개념","permalink":"https://kimyoungjae777.github.io/categories/Development/%EA%B8%B0%EB%B3%B8%EA%B0%9C%EB%85%90/"}],"tags":[{"name":"Development","slug":"Development","permalink":"https://kimyoungjae777.github.io/tags/Development/"},{"name":"기본개념","slug":"기본개념","permalink":"https://kimyoungjae777.github.io/tags/%EA%B8%B0%EB%B3%B8%EA%B0%9C%EB%85%90/"}],"author":"Young Jae Kim"},{"title":"Distance","slug":"Distance","date":"2022-07-15T00:00:00.000Z","updated":"2023-04-14T14:29:10.412Z","comments":true,"path":"2022/07/15/Distance/","link":"","permalink":"https://kimyoungjae777.github.io/2022/07/15/Distance/","excerpt":"","text":"DistanceReference:한국공학대학교 강지훈교수님 강의 中유클리디안 거리 가장 흔히 사용하는 거리측도 대응되는 x,y값 간 차이 제곱합의 제곱근으로써, 두 관측치 사이의 직선 거리를 의미함. 다차원 데이터에서도 마찬가지 이다. Manhattan Distance(격자 거리)맨하탄은 블럭이 나누어져 있어 직선으로 갈 수가 없다. 직선거리가 아닌 격자거리. 격자:바둑판처럼 가로세로를 일정한 간격으로 직각이 되게 짠 구조나 물건. 각 좌표의 차이의 절댓값의 합 Mahalanobis Distance 변수 내 분산,변수 간 공분산을 모두 반영하여 x,y,간 거리를 계산하는 방식⇒변수간 상관관계를 고려한 거리지표이다. 데이터의 공분산 행렬이 단위행렬인 경우는 유클리디안 거리와 동일함 공분산 행렬의 역행렬을 취했다는 것은 → 분산이 분모에 들어간다는 뜻 → 분산이 커지면 거리가 작아지고 , 분산이 작아지면 거리가 길어지고 마할라노비스거리가 제곱근이 취해져 있기 때문에 제곱근을 없앴다. 2차원 행렬로 비유를 했을시 , 쭈욱 대입하면 아래의 식으로 나타난다 y값에 0,0 을주고 대입하면 타원의 방정식이 나온다. 유클리디안 관점에서는 중앙점과 비교했을때, A가 더 멀다. 상관관계를 고려한 마할라노비스 거리로 보면 B가 더 멀다","categories":[{"name":"Machinelearning","slug":"Machinelearning","permalink":"https://kimyoungjae777.github.io/categories/Machinelearning/"},{"name":"알고리즘","slug":"Machinelearning/알고리즘","permalink":"https://kimyoungjae777.github.io/categories/Machinelearning/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"}],"tags":[{"name":"Machinelearning","slug":"Machinelearning","permalink":"https://kimyoungjae777.github.io/tags/Machinelearning/"},{"name":"알고리즘","slug":"알고리즘","permalink":"https://kimyoungjae777.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"}],"author":"Young Jae Kim"},{"title":"KNN","slug":"KNN","date":"2022-05-15T00:00:00.000Z","updated":"2023-04-14T14:29:10.416Z","comments":true,"path":"2022/05/15/KNN/","link":"","permalink":"https://kimyoungjae777.github.io/2022/05/15/KNN/","excerpt":"","text":"KNN (K-nearest neighbor)출처:한국공학대학교 강지훈교수님 강의 中Classification 분류나 예측을 진행할때 나랑 가장 가까운 이웃 k개를 고려하겠다. &lt;나랑 가까운 이웃 한명이 검정색이면 검정색으로 판단&gt; &lt;파란색의 가장 가까운 이웃을 확인해본 결과 검정색 이므로 파란색도 검정색으로 분류되었다.&gt; &lt;K&#x3D;3 일 경우 형광색 친구를 분류한다고 하였을때 이웃중 파란색이 2개 검정색이 한개이기 때문에 파란색으로 분류된다. 분류를 원하는 관측치의 주변 N개의 데이터(근접 이웃)을 골라서, 주변대세를 확인 (다수결의 원칙으로) Prediction 인접 K개의 데이터의 수치를 확인해줘서 그 데이터의 평균을 검은점의 예측치로 설정해준다. How to find optimal k?k의 결정 k가 너무 큰 경우, KNN모델이 지나치게 일반화됨 K가 너무 작은 경우,KNN 모델의 예측 결과의 분산이 큼 주로 이것저것 해보고 error이 가장 작은 k를 설정하여준다. 거리 척도의 결정 상황에 맞는 거리척도를 사용하여야 한다. 거리척도의 종류:Minkowski distance , Euclidean distance, Citi block distance, Mahalanobis distance, Correlation distance 등 Distance유클리디안 거리 가장 흔히 사용하는 거리측도 대응되는 x,y값 간 차이 제곱합의 제곱근으로써, 두 관측치 사이의 직선 거리를 의미함. 다차원 데이터에서도 마찬가지 이다. Manhattan Distance(격자 거리)맨하탄은 블럭이 나누어져 있어 직선으로 갈 수가 없다. 직선거리가 아닌 격자거리. 격자:바둑판처럼 가로세로를 일정한 간격으로 직각이 되게 짠 구조나 물건. 각 좌표의 차이의 절댓값의 합 Mahalanobis Distance 변수 내 분산,변수 간 공분산을 모두 반영하여 x,y,간 거리를 계산하는 방식⇒변수간 상관관계를 고려한 거리지표이다. 데이터의 공분산 행렬이 단위행렬인 경우는 유클리디안 거리와 동일함 공분산 행렬의 역행렬을 취했다는 것은 → 분산이 분모에 들어간다는 뜻 → 분산이 커지면 거리가 작아지고 , 분산이 작아지면 거리가 길어지고 마할라노비스거리가 제곱근이 취해져 있기 때문에 제곱근을 없앴다. 2차원 행렬로 비유를 했을시 , 쭈욱 대입하면 아래의 식으로 나타난다 y값에 0,0 을주고 대입하면 타원의 방정식이 나온다. 유클리디안 관점에서는 중앙점과 비교했을때, A가 더 멀다. 상관관계를 고려한 마할라노비스 거리로 보면 B가 더 멀다","categories":[{"name":"Machinelearning","slug":"Machinelearning","permalink":"https://kimyoungjae777.github.io/categories/Machinelearning/"},{"name":"알고리즘","slug":"Machinelearning/알고리즘","permalink":"https://kimyoungjae777.github.io/categories/Machinelearning/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"}],"tags":[{"name":"Machinelearning","slug":"Machinelearning","permalink":"https://kimyoungjae777.github.io/tags/Machinelearning/"},{"name":"알고리즘","slug":"알고리즘","permalink":"https://kimyoungjae777.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"}],"author":"Young Jae Kim"},{"title":"LGBM","slug":"LGBM","date":"2022-04-15T00:00:00.000Z","updated":"2023-04-14T14:29:10.418Z","comments":true,"path":"2022/04/15/LGBM/","link":"","permalink":"https://kimyoungjae777.github.io/2022/04/15/LGBM/","excerpt":"","text":"LGBM출처:고려대학교 산업경영공학부 DSBA 연구실앙상블 → 여러 예측기를 수집해서 단일 예측기 보다 더 좋은 예측기를 만드는 것. 일반적으로 앙상블 기법을 사용하면 , 예측기 하나로 훈련하였을때 보다 , 편향은 비슷하지만 분산이 줄어든다고 알려져 있다 ![Untitled](images&#x2F;LGBM&#x2F; 배깅(bagging) 원데이터 집합으로부터 크기가 같은 표본을 여러 번 단순임의 복원추출하여 각 표본(붓스트랩 표본) 에 대해 분류기를 생성한 후 그 결과를 앙상블하는 방법이다. 반복추출 방법을 사용하기 때문에 같은 데이터가 한 표본에 여러 번 추출될 수도 있고, 어떤 데이터는 추출되지 않을수도 있다. 부스팅(boosting) 배깅의 과정과 유사하나 붓스트랩 표본을 구성하는 sampling 과정에서 각 자료에 동일한 확율을 부여하는 것이 아니라, 분류가 잘못된 데이터에- 더 큰 가중을 주어 표본을 추출한다. 랜덤포레스트(random forest) 배깅에 랜덤 과정을 추가한 방법이다. 각 노드마다 모든 예측변수 안에서 최적의 분할을 선택하는 방법 대신 예측변수들을 임의로 추출하고, 추출된 변수 내에서 최적의 분할을 만들어 나가는 방법을 사용한다. 붓스트랩(Boostrap) 붓스트랩은 평가를 반복한다는 측면에서 교차검증과 유사하나, 훈련용 자료를 반복 재선정한다는 점에서 차이가 있다. 즉 붓스트랩은 관측치를 한번 이상 훈련용 자료로 사용하는 복원추출법에 기반한다. 붓스트랩은 전체 데이터의 양이 크지않은 경우의 모형평가에 가장 적합하다. LGBM Ensemble Learning:Gradient Boosting Machine(GBM) Gradient Boosting&#x3D;Gradient Descent+Boosting Gradient Descent: 첫번째 데이터에서 잘 못 맞춘 데이터들에 가중치를 주어, 두번째 모델 에서는 더 많은양을 만들어 준다. 또, 두번째 모델에서 잘못 매칭한 데이터들 에게 가중치를 주어서, 세번째 모델을 만들어주는 그러한 방식으로 모델을 반복한다. Fit an addictive model(ensemble) in a foward stage-wise manner → bagging 처럼 한번에 딱 학습을 시키는게 아니고 위에 언급한 것 처럼 하나씩 하나씩 더해가면서 모델을 학습 시켜나가는 모델 Adaptive boostingIn each stage, introduce a weak leaner to compensate the shortcomings of existing weak leaners ⇒ 모델을 거듭할수록, weak leaner 가 만들어 지면서 이전에 가졌던 오류에 대해 해결할 수 있는 능력을 만든다. → 이러한 weak learner 를 만들기 위해 , 앞서 보였던 모델의 shortcoming 을 더 많이 샘플링 해주세요 이런 뜻. Gradient Boosting그라디언트 부스팅은, Regression,Classification,Ranking 을 다 할 수 있다. 이 셋의 다르기는 loss function 에서 차이가 날 뿐, concept 은 동일하다. Regression 으로 설명하기가 가장 직관적이기 때문에, Regression 모델로써 concept 을 설명하겠다.얘는 adaptive boosting 과는 달리, 샘플링을 따로 시행하지는 않는다. 잔차를 목푯값 (y) 으로 놓고 계속해서 반복하면서 잔차에 대한 식을 만들어 낸다. 잔차를 목표값으로 잡아두면, 앞선 모델이 맞추지 못한 만큼만 맞추려고 노력을 하기때문에, 앞선 모델의 결과물과 뒷 모델의 결과물을 더하면 정답이 나온다. Weak learner 를 boosting 시키겠다 , 경사도를 통해서, Q1) 손실함수의 gradient(경사도) 가 0 에 가까울때 까지 미분을 해준다. Q1→ Gradient 가 0 인가? → the end Gradient 가 0이 아닌가?→ 아니라면 weight 를 gradinet 의 반대방향으로 움직이면 된다. 얼마만큼 움직이냐 잘 모르니까 조금씩 조금씩 움직여라 처음, decision tree 로 split point 를 잡아, regression 해준 부분의 잔차를 보면 높은것을 알 수 있다. GBM에서는 이 잔차를 기준으로 또 Split point 를 잡아주면서(이러한 과정에서 손실함수가 들어가며 손실함수의 gradient 를 줄여나가는 과정에서 gradient descent 개념이 들어가는 것) 점점 잔차를 줄여 나가는 것을 볼 수 있다. 처음에는 회귀식이 안좋게 나오는데 iteration 이 반복 될수록 회귀식이 좋아지는것으로 볼 수 있다. Overfitting problem in GBMGBM 의 가장큰 문제점은 오차를 기반으로 모델을 형성 하기때문에(애초에 모델 자체가 반복을 거듭 할수록, 전 모델의 오차를 줄여나가는 모델이기 때문에 오버피팅 문제는 필연적) 우리가 어찌 할수 없는 오차까지도 모델에 학습시키어서 오버피팅 문제를 불러 일으킨다 과적합 해결법 Subsampling→각각의 모델을 만들때 샘플링을 랜덤으로 80% 만해서 모델을 만들어준다 Shrinkage- original 알고리즘들은 전에 만들어진 모델들과 뒤로 갈수록 만들어지는 모델들에, 영향력이 동등했는데 , shrinkage 를 쓰면 , 뒤에 만들어지는 모델들에 대해서 , 가중치를 적게 두어 만들어준다. Early Stopping- validation error 가 증가 할 것 같으면 미리 중지를 시키는것 GBM 과 Random Forest GBM RandomForest 퍼포먼스 우수하냐 Yes Yes 변수의 중요도를 나타낼수 있느냐 Yes Yes Information Gain:Split point를 통해서 얼마나 혼잡도,불순도가 낮아지는가. Information Gain 을 통해 그 변수의 영향도를 체크 할 수 있다. LightGBMGOSS 모든 피쳐들을 검사하면 시간이 많이 걸리기 때문에 이를 막기위해서, Gradient-based One-side Sampling (GOSS) 를 사용→ Large gradient 는 keep 하고 small gradient 는 드랍 하는 방식으로, 1000개 데이터를 모두 탐색하는 것이 아니라 gradient 가 큰 것 위주로 탐색하는 방식 → 탐색횟수를 줄이는 것 EFB Exclusive Feature Bundleing(EFB)→ 모든피쳐를 탐색할 필요를 없애는 것 그렇다면 bundle 을 어떻게 찾을까요? Graph coloring problem 으로 해결가능 , 각각의 노드는 피쳐이고, edge 는 피쳐들간의 conflict → conflict 가 많은 애들은 bundling 이 되면 안됨(중복이 많이 들어갔으니까), conflict 가 없는 애들 끼리는 bundling 을 해도 된다. Greed bundling 계산법 edge 의 강도: 두 변수의 conflict 강도 edge: 동시에 0이아닌 객체의 수. degree 시작점을 degree의 내림차순으로 정리 해준다음. degree가 높은것 부터 시작하고, cutoff 는 hyperparameter 인데, cut-off가 0.2라는 말은, N&#x3D;10 이기 때문에 2회 이상 Nonzero value 가 겹치게 되면, bundleing이 안되는 것. cut-off 기준에 맞지 않기 때문에 x5는 고립이 된다. feature merge 를 쉽게 해주기 위해 feature의 위치를 살짝 조정 하여준다. feature 를 merge 하는방법. Add. offset add offset→bundling 을 하기위한 대상이 되는 변수에다가 기준이 되는 변수가 가질 수 있는 최대 값을 더해준다. conflict 가 일어난 부분은 그대로 기준 변수가 가지는 값을 더해준다. Decision Tree","categories":[{"name":"Machinelearning","slug":"Machinelearning","permalink":"https://kimyoungjae777.github.io/categories/Machinelearning/"},{"name":"알고리즘","slug":"Machinelearning/알고리즘","permalink":"https://kimyoungjae777.github.io/categories/Machinelearning/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"}],"tags":[{"name":"Machinelearning","slug":"Machinelearning","permalink":"https://kimyoungjae777.github.io/tags/Machinelearning/"},{"name":"알고리즘","slug":"알고리즘","permalink":"https://kimyoungjae777.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"}],"author":"Young Jae Kim"},{"title":"넘파이 기초","slug":"num","date":"2022-03-23T00:00:00.000Z","updated":"2023-04-14T14:29:10.451Z","comments":true,"path":"2022/03/23/num/","link":"","permalink":"https://kimyoungjae777.github.io/2022/03/23/num/","excerpt":"","text":"Numpy 라이브러리 불러오기123import numpy as npprint(np.__version__) 1.21.5 배열로 변환 1부터 10까지의 리스트를 만든다. Numpy 배열로 변환해서 저장한다. 123456temp=[1,2,3,4,5,7,8,9,10] #지금은 리스트다arr=np.array(temp)print(arr)type(arr)#array 로 바뀌었다. [ 1 2 3 4 5 7 8 9 10] numpy.ndarray arr 배열 숫자 5 출력 12arr[4] # 인덱싱 파이썬은 0번째 부터!!arr[4:8] array([5, 7, 8, 9]) Numpy를 이용하여 기초통계 함수를 사용한다 1234print(np.mean(arr))print(np.sum(arr))print(np.median(arr))print(np.std(arr)) 5.444444444444445 49 5.0 3.02254900194121 1 사칙연산 123456math_score=[90,80,88]english_score=[80,70,90]total_score=math_score+english_scoretotal_score# 더해지는게 아니라 붙혀지는 형태로 나옴 [90, 80, 88, 80, 70, 90] 1 123456789math_score=[90,80,88]english_score=[80,70,90]math_arr=np.array(math_score)english_arr=np.array(english_score)totalscore=math_arr+english_arrtotalscore array([170, 150, 178]) 12np.min(totalscore)np.max(totalscore) 178 123456# 덧셈print(&quot;덧셈:&quot;,np.add(math_arr,english_arr))print(&quot;뺄셈:&quot;,np.subtract(math_arr,english_arr))print(&quot;곱셈:&quot;,np.multiply(math_arr,english_arr))print(&quot;뺄셈:&quot;,np.divide(math_arr,english_arr))print(&quot;거듭제곱:&quot;,np.power(math_arr,english_arr)) 덧셈: [170 150 178] 뺄셈: [10 10 -2] 곱셈: [7200 5600 7920] 뺄셈: [1.125 1.14285714 0.97777778] 거듭제곱: [0 0 0] 배열의 생성 0차원부터 3차원으로 생성하는 방법 12345temp_arr=np.array(20)print(temp_arr)print(type(temp_arr))print(temp_arr.shape) 20 &lt;class &#39;numpy.ndarray&#39;&gt; () 1234567#1차원 배열temp_arr=np.array([1,2,3])print(temp_arr)print(type(temp_arr))print(temp_arr.shape) # 3개의 사이즈를 가지고 있는 1차원 배열이다.print(temp_arr.ndim) #차원 출력 [1 2 3] &lt;class &#39;numpy.ndarray&#39;&gt; (3,) 1 123456# 2차원 배열temp_arr=np.array([[1,2,3],[4,5,6]])print(temp_arr)print(type(temp_arr))print(temp_arr.shape) # 2x3 배열print(temp_arr.ndim) #차원 출력 [[1 2 3] [4 5 6]] &lt;class &#39;numpy.ndarray&#39;&gt; (2, 3) 2 123456# 3차원 배열temp_arr=np.array([[[1,2,3],[4,5,6],[1,2,3],[4,5,6]]])print(temp_arr)print(type(temp_arr))print(temp_arr.shape) # 2x3 배열print(temp_arr.ndim) #차원 출력 [[[1 2 3] [4 5 6] [1 2 3] [4 5 6]]] &lt;class &#39;numpy.ndarray&#39;&gt; (1, 4, 3) 3 12345temp_arr=np.array([1,2,3,4],ndmin=2)print(temp_arr)print(type(temp_arr))print(temp_arr.shape) print(temp_arr.ndim) [[1 2 3 4]] &lt;class &#39;numpy.ndarray&#39;&gt; (1, 4) 2 소숫점 정렬1234temp_arr=np.trunc([-1.23,1.23])temp_arr #소숫점이 절삭됨 array([-1., 1.]) 12temp_arr=np.fix([-1.23,1.23])temp_arr #소숫점이 절삭됨 array([-1., 1.]) 12temp_arr=np.around([-1.23789,1.23789],4) #4는 자릿수 파라미터temp_arr #소숫점이 반올림됨 array([-1.2379, 1.2379]) 123temp_arr=np.floor([-1.23789,1.23789]) #4는 자릿수 파라미터print(temp_arr) #소숫점이 반올림됨print(type(temp_arr)) [-2. 1.] &lt;class &#39;numpy.ndarray&#39;&gt; 12temp_arr=np.ceil([-1.23789,1.23789]) #4는 자릿수 파라미터print(temp_arr) #소숫점이 반올림됨 [-1. 2.] 1 배열을 생성하는 다양한 방법들123# arrangetemp_arr=np.arange(1,9,3) # 숫자 범위 지정해주고 세번째 파라미터는 step 을 의미 temp_arr array([1, 4, 7]) 123456zero_arr=np.zeros((2,3))print(zero_arr)print(type(zero_arr))print(zero_arr.ndim) print(zero_arr.shape) print(zero_arr.dtype) [[0. 0. 0.] [0. 0. 0.]] &lt;class &#39;numpy.ndarray&#39;&gt; 2 (2, 3) float64 123456789temp_arr=np.ones((2,6))temp_res_arr=temp_arr.reshape(3,4) #파라미터에 -1 을넣어주면 알아서 계산이된다print(temp_res_arr)print(type(temp_res_arr))print(temp_res_arr.ndim) print(temp_res_arr.shape) print(temp_res_arr.dtype) [[1. 1. 1. 1.] [1. 1. 1. 1.] [1. 1. 1. 1.]] &lt;class &#39;numpy.ndarray&#39;&gt; 2 (3, 4) float64 numpy 조건식! np.where 12temp_arr=np.arange(10)temp_arr array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) 1234# 5보다 작은 값은 원래값으로 변환# 5보다 큰값은 원래값 * 10# 조건식이 하나만 필요할때 np.wherenp.where(temp_arr&lt;5,temp_arr,temp_arr*10) array([ 0, 1, 2, 3, 4, 50, 60, 70, 80, 90]) 123# 0~100 까지의 배열 만들고 , 50보다 작은 값은 *10temp_arr=np.arange(100)np.where(temp_arr&lt;50,temp_arr,temp_arr*10) # 두번쨰 파라미터 조건식에 만족x ~다 세번째 파라미터 조건식에 맞으면 ~다 array([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 500, 510, 520, 530, 540, 550, 560, 570, 580, 590, 600, 610, 620, 630, 640, 650, 660, 670, 680, 690, 700, 710, 720, 730, 740, 750, 760, 770, 780, 790, 800, 810, 820, 830, 840, 850, 860, 870, 880, 890, 900, 910, 920, 930, 940, 950, 960, 970, 980, 990]) np.select 123456789temp_arr=np.arange(10)temp_arrcondlist=[temp_arr&gt;5,temp_arr&lt;2]choielist=[temp_arr*2,temp_arr+100]np.select(condlist,choielist,default=temp_arr)# 5보다 큰 값은 곱하기 2 , 2보다 작은 값은 더하기 100# broadcasting 확인해보기 array([100, 101, 2, 3, 4, 5, 12, 14, 16, 18])","categories":[{"name":"데이터분석","slug":"데이터분석","permalink":"https://kimyoungjae777.github.io/categories/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B6%84%EC%84%9D/"}],"tags":[],"author":"Young Jae Kim"},{"title":"Spring과SpringBoot의 차이","slug":"SpringVS_SpringBoot","date":"2022-03-19T00:00:00.000Z","updated":"2023-04-14T14:29:10.430Z","comments":true,"path":"2022/03/19/SpringVS_SpringBoot/","link":"","permalink":"https://kimyoungjae777.github.io/2022/03/19/SpringVS_SpringBoot/","excerpt":"","text":"Spring 과 SpringBoot의 차이스프링(spring)이란? 정확한 표현으로는 ‘스프링 프레임워크’ 스프링 프레임워크는 자바에서 가장 많이 사용되는 프레임워크 의존성 주입과(DI) 제어역전(IOC), 관점 지향 프로그래밍(AOP) 이 가장 중요한 요소. 위 요소들을 통해 느슨한 결합을 달성할 수 있음. 위와 같이 느슨한 결합으로 개발한 어플리케이션은 단위테스트를 수행하기 용이함. 의존성 주입(DI,Dependency injection) 예제 코드와 같이 DI를 사용하지 않은 코드의 경우 Controller는 MyService 객체에 의존하게 됨 예제 코드 처럼 객체의 인스턴스를 얻게 되면 객체간의 결합도가 올라감. 예제 코드 처럼 객체의 인스턴스를 얻게 되면 객체간의 결합도가 올라감. 이런 코드 작성은 단위테스트를 위해 Mock 객체를 사용할 수 없게 됨 의존성 주입을 사용한경우 예제 코드와 같이 DI를 사용하는 코드의 경우 @Service, @Autowired 어노테이션을 통해 MyService의 인스턴스를 획득 위와 같이 코드를 작성하면 단위테스트 상황에서 Service 객체를 Mock 객체로 대체하여 쉽게 테스트 할 수 있음. 인스턴스를 직접 호출하는게 아니라 스프링 컨테이너에 있는 서비스 객체를 주입 받는 형태이기 때문에 진짜 Myservice에 인스턴스를 생성해주는게 아니라,MOCK 객체를 따로 만들어 주어서 Myservice 라는 객체 대신에 mock 객체를 넣어줄수 있다는 장점 이렇게되면 controller 를 테스트 할때 myservice 라는 객체는 테스트를 해주지 않아도 된다. (mock 객체로 대체 시키면 controller만 직접 테스트를 할 수 있다.) AOP 스프링 프레임워크에서 제공하는 강력한 기능 중 하나 AOP는 쉽게 말해, OOP를 보완하는 수단으로, 여러 곳에 쓰이는 공통 기능을 모듈화하여 필요한 곳에 연결함으로써 유지보수 또는 재사용에 용이하도록 하는 것을 의미 AOP를 통해 기존 프로젝트에 다양한 기능을 로직 수정 없이 추가할 수 있음. 이런 개발 방식을 통해 결합도를 낮춘 개발이 가능함. 스프링 프레임워크의 대표적 모듈 Spring JDBC Spring MVC Spirng AOP Spring ORM Spring Test Spring Expression Language 스프링 부트가 나오게 된 이유 스프링 부트는 단지 실행만 하면 되는 스프링 기반의 어플리케이션을 쉽게 만들 수 있다. 스프링은 다양한 기능을 제공하고 있지만 그 기능을 사용하기 위한 설정에 많은 시간이 걸린다. 스프링 부트가 제공하는 기능 스프링 부트는 자동설정을 이용 -어플리케이션 개발에 필요한 모든 디펜던시를 프레임워크에서 관리 -jar파일이 클래스 패스에 있는경우 스프링 부트는 Dispatcher Servlet 으로 자동 구성됨 -스프링 부트는 미리 설정되어 있는 Starter 프로젝트를 제공 -xml설정 없이 자바 코드를 통해 설정할 수 있음 어플리케이션을 개발하면서 사용되는 디펜던시들은 호환되는 버전으로 관리 해줘야함 -이런 복잡도를 줄이기 위해 스프링 부트는 SpringBoot-Starter를 제공하여 자동으로 호환되는 버전을 관리 모니터링 관리를 위한 스프링 액추에이더 제공-서비스가 정상적으로 동작하는지 상태 모니터링 기능 제공 -스프링 액추에이터는 스프링 부트에서 제공하는 상태 정보를 보다 쉽게 모니터링할 수 있게 기능을 제공 스프링 부트 프로젝트의 의존성 관리-spring boot starter dependency를 통해 다양한 패키지를 수용하고 있음. -이를 통해 개발자는 dependency 관리(호환성 체크 등)에 대해 고려할 필요가 없어짐. 스프링 부트 프로젝트의 starter 디펜던시","categories":[{"name":"Development","slug":"Development","permalink":"https://kimyoungjae777.github.io/categories/Development/"},{"name":"기본개념","slug":"Development/기본개념","permalink":"https://kimyoungjae777.github.io/categories/Development/%EA%B8%B0%EB%B3%B8%EA%B0%9C%EB%85%90/"}],"tags":[{"name":"Development","slug":"Development","permalink":"https://kimyoungjae777.github.io/tags/Development/"},{"name":"기본개념","slug":"기본개념","permalink":"https://kimyoungjae777.github.io/tags/%EA%B8%B0%EB%B3%B8%EA%B0%9C%EB%85%90/"}],"author":"Young Jae Kim"},{"title":"깃허브 자료올리기","slug":"github_update_blog","date":"2022-03-19T00:00:00.000Z","updated":"2023-04-14T14:29:10.445Z","comments":true,"path":"2022/03/19/github_update_blog/","link":"","permalink":"https://kimyoungjae777.github.io/2022/03/19/github_update_blog/","excerpt":"","text":"github 블로그에 공부 자료 올려보기 저번 시간에는 hexo를 통해 github 블로그를 만드는 법을 알아 보았는데요, 이번에는 블로그에 자료를 직접 올려보겠습니다. Notion 으로 작성한 공부일지를 올려보자 !! . step 1) notion을 마크다운 형식으로 export 하기. source&#x2F;images&#x2F;github_update_blog 그렇게 되면 아래의 그림과 같이 마크다운 파일과 image 파일이 나오게 됩니다 step 2) export 한 파일들을 myblog(깃허브와 연동시켜준 로컬 파일) 로 옮겨 줍니다. 포스트 파일에 마크다운 파일을 넣어줍니다 이제 포스팅 해야하는 이미지 파일들은 images 파일을 만들어주어서 여기다 넣어줍니다. (hexo 개발자가 그렇게 하래요~) images 파일에 notion의 이미지 파일을 넣어 줍니다. 파이참으로 들어간 이후로, 이미지의 경로를 설정하여줍니다. 처음, 이미지 파일들이 저렇게 똑같은 글자로 되어있을 것 입니다. 이 글자들을 모두 images/make_blog/이미지 파일이름 이렇게 지정해두어야 합니다 . 그렇다면 이렇게 하나하나 모두 바꿔주기 힘드니. 같은 글자를 드래그 및 복사 해준다음에 ctrl+f replace all 로 경로를 모두 바꾸어줍니다. step3) 저번 포스팅과 같이 hexo server 로 확인해줍니다 . 그러면 저의 깃허브 블로그 사이트에 저번 노션 기록이 올라간 것을 확인 하실수 있습니다. step4)배포해주기12345git add . git commit -m &quot;update&quot;git push hexo generate --deploy 지금까지 한 파일들을 git으로 올려주고 배포를 시켜준다 . !!","categories":[{"name":"Development","slug":"Development","permalink":"https://kimyoungjae777.github.io/categories/Development/"},{"name":"gitBlog","slug":"Development/gitBlog","permalink":"https://kimyoungjae777.github.io/categories/Development/gitBlog/"}],"tags":[{"name":"Development","slug":"Development","permalink":"https://kimyoungjae777.github.io/tags/Development/"},{"name":"gitBlog","slug":"gitBlog","permalink":"https://kimyoungjae777.github.io/tags/gitBlog/"}],"author":"Young Jae Kim"},{"title":"pandas's 10minutes","slug":"2022-04-12-pands_10_minutes","date":"2022-03-16T00:00:00.000Z","updated":"2023-04-14T14:29:10.406Z","comments":true,"path":"2022/03/16/2022-04-12-pands_10_minutes/","link":"","permalink":"https://kimyoungjae777.github.io/2022/03/16/2022-04-12-pands_10_minutes/","excerpt":"","text":"table.dataframe { white-space: normal; width: 100%; height: 240px; display: block; overflow: auto; font-family: Arial, sans-serif; font-size: 0.9rem; line-height: 20px; text-align: center; border: 0px !important; } table.dataframe th &#123; text-align: center; font-weight: bold; padding: 8px; &#125; table.dataframe td &#123; text-align: center; padding: 8px; &#125; table.dataframe tr:hover &#123; background: #b8d1f3; &#125; .output_prompt &#123; overflow: auto; font-size: 0.9rem; line-height: 1.45; border-radius: 0.3rem; -webkit-overflow-scrolling: touch; padding: 0.8rem; margin-top: 0; margin-bottom: 15px; font: 1rem Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; color: $code-text-color; border: solid 1px $border-color; border-radius: 0.3rem; word-break: normal; white-space: pre; &#125; .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: center !important; padding: 8px; } .page__content p { margin: 0 0 0px !important; } .page__content p &gt; strong { font-size: 0.8rem !important; } 123import pandas as pd import numpy as npimport matplotlib.pyplot as plt pandas 10분 완성 출처-BSD-3-Clause Object Creation(객체생성) pandas 는 값을 가지고 있는 리스트를 통해 Series를 만들고, 정수로 만들어진 인덱스를 기본값으로 불러올 것 입니다. 12s=pd.Series([1,3,5,np.nan,6,8])s 0 1.0 1 3.0 2 5.0 3 NaN 4 6.0 5 8.0 dtype: float64 datetime 인덱스와 레이블이 있는 열을 가지고 있는 numpy 배열을 전달하여 데이터프레임을 만듭니다. 12345dates=pd.date_range(&#x27;20130101&#x27;,periods=6)dates df=pd.DataFrame(np.random.randn(6,4),index=dates,columns=list(&#x27;ABCD&#x27;))# value 에 값을 넣어주고 , index 에는 date를 넣어주고, 컬럼에는 ABCDdf A B C D 2013-01-01 0.867751 0.483668 0.804306 -0.943246 2013-01-02 -0.947881 0.482789 -0.044766 -0.799984 2013-01-03 0.089794 0.407933 -0.081971 1.088698 2013-01-04 -0.671818 1.295661 -0.677348 0.135460 2013-01-05 0.519066 -1.204134 1.747446 0.641655 2013-01-06 -0.528972 -0.741428 0.454718 -0.983917 Series 와 같은 것으로 변환될 수 있는 객체들의 dict로 구성된 데이터프레임을 만듭니다. 12345678d2=pd.DataFrame(&#123;&#x27;A&#x27;:1, &#x27;B&#x27;:pd.Timestamp(&#x27;20130102&#x27;), &#x27;C&#x27;:pd.Series(1,index=list(range(4)),dtype=&#x27;float32&#x27;), &#x27;D&#x27;:np.array([3]*4,dtype=&#x27;int32&#x27;), &#x27;E&#x27;:pd.Categorical([&quot;test&quot;,&quot;train&quot;,&quot;test&quot;,&quot;train&quot;]), &#x27;F&#x27;:&#x27;foo&#x27;&#125;)d2 A B C D E F 0 1 2013-01-02 1.0 3 test foo 1 1 2013-01-02 1.0 3 train foo 2 1 2013-01-02 1.0 3 test foo 3 1 2013-01-02 1.0 3 train foo 1d2.dtypes # 다양한 데이터 타입으로 저장 A int64 B datetime64[ns] C float32 D int32 E category F object dtype: object 2.Viewing Data (데이터 확인하기.)1df.tail(3)# 데이터프레임을 끝에서 3줄만 출력 A B C D 2013-01-04 -0.671818 1.295661 -0.677348 0.135460 2013-01-05 0.519066 -1.204134 1.747446 0.641655 2013-01-06 -0.528972 -0.741428 0.454718 -0.983917 12print(df.index) # 인덱스를 보여주며, 인덱스의 data_type 를 알려줍니다. print(d2.index) DatetimeIndex(['2013-01-01', '2013-01-02', '2013-01-03', '2013-01-04', '2013-01-05', '2013-01-06'], dtype='datetime64[ns]', freq='D') Int64Index([0, 1, 2, 3], dtype='int64') 12print(df.columns) # 컬럼를 보여주며, 컬럼의 data_type 를 알려줍니다. print(d2.columns) Index(['A', 'B', 'C', 'D'], dtype='object') Index(['A', 'B', 'C', 'D', 'E', 'F'], dtype='object') 12print(df.values) # 인덱스를 보여주며, 인덱스의 data_type 를 알려줍니다. print(d2.values) [[ 0.86775054 0.48366818 0.80430646 -0.94324588] [-0.947881 0.48278913 -0.0447657 -0.79998396] [ 0.08979353 0.40793256 -0.08197077 1.08869764] [-0.67181835 1.29566098 -0.67734781 0.13546042] [ 0.51906627 -1.20413362 1.74744631 0.64165489] [-0.52897166 -0.74142796 0.4547179 -0.98391684]] [[1 Timestamp('2013-01-02 00:00:00') 1.0 3 'test' 'foo'] [1 Timestamp('2013-01-02 00:00:00') 1.0 3 'train' 'foo'] [1 Timestamp('2013-01-02 00:00:00') 1.0 3 'test' 'foo'] [1 Timestamp('2013-01-02 00:00:00') 1.0 3 'train' 'foo']] 12print(df.describe()) # 데이터의 대략적인 통계적 정보요약을 보여줍니다print(d2.describe()) A B C D count 6.000000 6.000000 6.000000 6.000000 mean -0.112010 0.120748 0.367064 -0.143556 std 0.719004 0.919167 0.844553 0.893248 min -0.947881 -1.204134 -0.677348 -0.983917 25% -0.636107 -0.454088 -0.072670 -0.907430 50% -0.219589 0.445361 0.204976 -0.332262 75% 0.411748 0.483448 0.716909 0.515106 max 0.867751 1.295661 1.747446 1.088698 A C D count 4.0 4.0 4.0 mean 1.0 1.0 3.0 std 0.0 0.0 0.0 min 1.0 1.0 3.0 25% 1.0 1.0 3.0 50% 1.0 1.0 3.0 75% 1.0 1.0 3.0 max 1.0 1.0 3.0 12print(df.T) # 데이터를 전치 합니다print(d2.T) 2013-01-01 2013-01-02 2013-01-03 2013-01-04 2013-01-05 2013-01-06 A 0.867751 -0.947881 0.089794 -0.671818 0.519066 -0.528972 B 0.483668 0.482789 0.407933 1.295661 -1.204134 -0.741428 C 0.804306 -0.044766 -0.081971 -0.677348 1.747446 0.454718 D -0.943246 -0.799984 1.088698 0.135460 0.641655 -0.983917 0 1 2 \\ A 1 1 1 B 2013-01-02 00:00:00 2013-01-02 00:00:00 2013-01-02 00:00:00 C 1.0 1.0 1.0 D 3 3 3 E test train test F foo foo foo 3 A 1 B 2013-01-02 00:00:00 C 1.0 D 3 E train F foo 12print(df.sort_index(axis=1,ascending=False)) # 축 별로 정렬. axis=1 =&gt;goddmf rlwnsdmfh print(df.sort_index(axis=0,ascending=False)) D C B A 2013-01-01 -0.943246 0.804306 0.483668 0.867751 2013-01-02 -0.799984 -0.044766 0.482789 -0.947881 2013-01-03 1.088698 -0.081971 0.407933 0.089794 2013-01-04 0.135460 -0.677348 1.295661 -0.671818 2013-01-05 0.641655 1.747446 -1.204134 0.519066 2013-01-06 -0.983917 0.454718 -0.741428 -0.528972 A B C D 2013-01-06 -0.528972 -0.741428 0.454718 -0.983917 2013-01-05 0.519066 -1.204134 1.747446 0.641655 2013-01-04 -0.671818 1.295661 -0.677348 0.135460 2013-01-03 0.089794 0.407933 -0.081971 1.088698 2013-01-02 -0.947881 0.482789 -0.044766 -0.799984 2013-01-01 0.867751 0.483668 0.804306 -0.943246 1df.sort_values(by=&#x27;B&#x27;,ascending=False) #값별로 정렬 A B C D 2013-01-04 -0.671818 1.295661 -0.677348 0.135460 2013-01-01 0.867751 0.483668 0.804306 -0.943246 2013-01-02 -0.947881 0.482789 -0.044766 -0.799984 2013-01-03 0.089794 0.407933 -0.081971 1.088698 2013-01-06 -0.528972 -0.741428 0.454718 -0.983917 2013-01-05 0.519066 -1.204134 1.747446 0.641655 3.Selection (선택)12#행을 분할하는 []를 통해 선택합니다.df[0:3]# 모든행 3열까지 출력 A B C D 2013-01-01 0.867751 0.483668 0.804306 -0.943246 2013-01-02 -0.947881 0.482789 -0.044766 -0.799984 2013-01-03 0.089794 0.407933 -0.081971 1.088698 12# 인덱스 코드로 출력 df[&#x27;20130102&#x27;:&#x27;20130104&#x27;] A B C D 2013-01-02 -0.947881 0.482789 -0.044766 -0.799984 2013-01-03 0.089794 0.407933 -0.081971 1.088698 2013-01-04 -0.671818 1.295661 -0.677348 0.135460 1df.loc[dates[0]] #dates 컬럼 모든것 출력 A 0.867751 B 0.483668 C 0.804306 D -0.943246 Name: 2013-01-01 00:00:00, dtype: float64 1df.loc[:,[&#x27;A&#x27;,&#x27;B&#x27;]] A B 2013-01-01 0.867751 0.483668 2013-01-02 -0.947881 0.482789 2013-01-03 0.089794 0.407933 2013-01-04 -0.671818 1.295661 2013-01-05 0.519066 -1.204134 2013-01-06 -0.528972 -0.741428 1df.loc[&quot;20130102&quot;:&#x27;20130104&#x27;,[&#x27;A&#x27;,&#x27;B&#x27;]] A B 2013-01-02 -0.947881 0.482789 2013-01-03 0.089794 0.407933 2013-01-04 -0.671818 1.295661 1df.loc[&#x27;20130102&#x27;,[&#x27;A&#x27;,&#x27;B&#x27;]] A -0.947881 B 0.482789 Name: 2013-01-02 00:00:00, dtype: float64 1df.at[dates[0],&#x27;A&#x27;] 0.8677505440016215 위치로 선택하기 1df.iloc[3] A -0.671818 B 1.295661 C -0.677348 D 0.135460 Name: 2013-01-04 00:00:00, dtype: float64 1df.iloc[3:5,0:2] A B 2013-01-04 -0.671818 1.295661 2013-01-05 0.519066 -1.204134 1df A B C D 2013-01-01 0.867751 0.483668 0.804306 -0.943246 2013-01-02 -0.947881 0.482789 -0.044766 -0.799984 2013-01-03 0.089794 0.407933 -0.081971 1.088698 2013-01-04 -0.671818 1.295661 -0.677348 0.135460 2013-01-05 0.519066 -1.204134 1.747446 0.641655 2013-01-06 -0.528972 -0.741428 0.454718 -0.983917 1df.iloc[[1,2,4],[0,2]] A C 2013-01-02 -0.947881 -0.044766 2013-01-03 0.089794 -0.081971 2013-01-05 0.519066 1.747446 1df.iloc[1:3,:] A B C D 2013-01-02 -0.947881 0.482789 -0.044766 -0.799984 2013-01-03 0.089794 0.407933 -0.081971 1.088698 1df.iloc[:,1:3] B C 2013-01-01 0.483668 0.804306 2013-01-02 0.482789 -0.044766 2013-01-03 0.407933 -0.081971 2013-01-04 1.295661 -0.677348 2013-01-05 -1.204134 1.747446 2013-01-06 -0.741428 0.454718 1df.iloc[1,1] 0.48278913296263115 1df.iat[1,1] 0.48278913296263115 Boolean Indexing 데이터를 선택하기 위해 단일 열의 값을 사용한다. 1df[df.A&gt;0] A B C D 2013-01-01 0.867751 0.483668 0.804306 -0.943246 2013-01-03 0.089794 0.407933 -0.081971 1.088698 2013-01-05 0.519066 -1.204134 1.747446 0.641655 1df[df&gt;0] A B C D 2013-01-01 0.867751 0.483668 0.804306 NaN 2013-01-02 NaN 0.482789 NaN NaN 2013-01-03 0.089794 0.407933 NaN 1.088698 2013-01-04 NaN 1.295661 NaN 0.135460 2013-01-05 0.519066 NaN 1.747446 0.641655 2013-01-06 NaN NaN 0.454718 NaN 필터링을 위한 메소드 isin()을 사용합니다 1df2=df.copy() 12df2[&#x27;E&#x27;]=[&#x27;one&#x27;,&#x27;one&#x27;,&#x27;two&#x27;,&#x27;three&#x27;,&#x27;four&#x27;,&#x27;two&#x27;]df2 A B C D E 2013-01-01 0.867751 0.483668 0.804306 -0.943246 one 2013-01-02 -0.947881 0.482789 -0.044766 -0.799984 one 2013-01-03 0.089794 0.407933 -0.081971 1.088698 two 2013-01-04 -0.671818 1.295661 -0.677348 0.135460 three 2013-01-05 0.519066 -1.204134 1.747446 0.641655 four 2013-01-06 -0.528972 -0.741428 0.454718 -0.983917 two 12df2[df2[&#x27;E&#x27;].isin([&#x27;two&#x27;,&#x27;four&#x27;])]print(df2) A B C D E 2013-01-01 0.867751 0.483668 0.804306 -0.943246 one 2013-01-02 -0.947881 0.482789 -0.044766 -0.799984 one 2013-01-03 0.089794 0.407933 -0.081971 1.088698 two 2013-01-04 -0.671818 1.295661 -0.677348 0.135460 three 2013-01-05 0.519066 -1.204134 1.747446 0.641655 four 2013-01-06 -0.528972 -0.741428 0.454718 -0.983917 two setting (설정) 새 열을 설정하면 데이터가 인덱스 별로 자동 정렬됩니다. 12s1=pd.Series([1,2,3,4,5,6],index=pd.date_range(&#x27;20130102&#x27;,periods=6))s1 2013-01-02 1 2013-01-03 2 2013-01-04 3 2013-01-05 4 2013-01-06 5 2013-01-07 6 Freq: D, dtype: int64 1df[&#x27;F&#x27;]=s1 12df.at[dates[0],&#x27;A&#x27;]=0df A B C D F 2013-01-01 0.000000 0.483668 0.804306 -0.943246 NaN 2013-01-02 -0.947881 0.482789 -0.044766 -0.799984 1.0 2013-01-03 0.089794 0.407933 -0.081971 1.088698 2.0 2013-01-04 -0.671818 1.295661 -0.677348 0.135460 3.0 2013-01-05 0.519066 -1.204134 1.747446 0.641655 4.0 2013-01-06 -0.528972 -0.741428 0.454718 -0.983917 5.0 12df.iat[0,1]=0df A B C D F 2013-01-01 0.000000 0.000000 0.804306 -0.943246 NaN 2013-01-02 -0.947881 0.482789 -0.044766 -0.799984 1.0 2013-01-03 0.089794 0.407933 -0.081971 1.088698 2.0 2013-01-04 -0.671818 1.295661 -0.677348 0.135460 3.0 2013-01-05 0.519066 -1.204134 1.747446 0.641655 4.0 2013-01-06 -0.528972 -0.741428 0.454718 -0.983917 5.0 12df.loc[:,&#x27;D&#x27;]=np.array([5]*len(df))df A B C D F 2013-01-01 0.000000 0.000000 0.804306 5 NaN 2013-01-02 -0.947881 0.482789 -0.044766 5 1.0 2013-01-03 0.089794 0.407933 -0.081971 5 2.0 2013-01-04 -0.671818 1.295661 -0.677348 5 3.0 2013-01-05 0.519066 -1.204134 1.747446 5 4.0 2013-01-06 -0.528972 -0.741428 0.454718 5 5.0 where 연산을 설정합니다1df2=df.copy() 12df2[df2&gt;0]=-df2df2 A B C D F 2013-01-01 0.000000 0.000000 -0.804306 -5 NaN 2013-01-02 -0.947881 -0.482789 -0.044766 -5 -1.0 2013-01-03 -0.089794 -0.407933 -0.081971 -5 -2.0 2013-01-04 -0.671818 -1.295661 -0.677348 -5 -3.0 2013-01-05 -0.519066 -1.204134 -1.747446 -5 -4.0 2013-01-06 -0.528972 -0.741428 -0.454718 -5 -5.0 4. Missing Data(결측치) pandas는 결측치를 표현하기 위해 주로 np.nan 값을 사용합니다. 이 방법은 기본 설정값이지만 계산에는 포함되지 않습니다. 12df1=df.reindex(index=dates[0:4],columns=list(df.columns)+[&#x27;E&#x27;])df1 A B C D F E 2013-01-01 0.000000 0.000000 0.804306 5 NaN NaN 2013-01-02 -0.947881 0.482789 -0.044766 5 1.0 NaN 2013-01-03 0.089794 0.407933 -0.081971 5 2.0 NaN 2013-01-04 -0.671818 1.295661 -0.677348 5 3.0 NaN 12df1.loc[dates[0]:dates[1],&#x27;E&#x27;]=1 #0과 1행렬 E 컬럼에 1을 넣어준다.df1 A B C D F E 2013-01-01 0.000000 0.000000 0.804306 5 NaN 1.0 2013-01-02 -0.947881 0.482789 -0.044766 5 1.0 1.0 2013-01-03 0.089794 0.407933 -0.081971 5 2.0 NaN 2013-01-04 -0.671818 1.295661 -0.677348 5 3.0 NaN 결측치를 가지고 있는 행들을 지운다. 1df1.dropna(how=&#x27;any&#x27;) # 어떤 컬럼이던지 결측치가 있으면 삭제해라 A B C D F E 2013-01-02 -0.947881 0.482789 -0.044766 5 1.0 1.0 결측치를 채워넣는다. 12df1=df1.fillna(value=5)df1 A B C D F E 2013-01-01 0.000000 0.000000 0.804306 5 5.0 1.0 2013-01-02 -0.947881 0.482789 -0.044766 5 1.0 1.0 2013-01-03 0.089794 0.407933 -0.081971 5 2.0 5.0 2013-01-04 -0.671818 1.295661 -0.677348 5 3.0 5.0 boolean 으로, 결측치 확인하기. 1pd.isna(df1) A B C D F E 2013-01-01 False False False False False False 2013-01-02 False False False False False False 2013-01-03 False False False False False False 2013-01-04 False False False False False False Operation (연산) Stats(통계) 1df A B C D F 2013-01-01 0.000000 0.000000 0.804306 5 NaN 2013-01-02 -0.947881 0.482789 -0.044766 5 1.0 2013-01-03 0.089794 0.407933 -0.081971 5 2.0 2013-01-04 -0.671818 1.295661 -0.677348 5 3.0 2013-01-05 0.519066 -1.204134 1.747446 5 4.0 2013-01-06 -0.528972 -0.741428 0.454718 5 5.0 1df.mean() # default 컬럼별 A -0.256635 B 0.040137 C 0.367064 D 5.000000 F 3.000000 dtype: float64 축을 바꾸어서도 실행할 수 있다 1df.mean(1) # 인덱스별 2013-01-01 1.451077 2013-01-02 1.098028 2013-01-03 1.483151 2013-01-04 1.589299 2013-01-05 2.012476 2013-01-06 1.836864 Freq: D, dtype: float64 123s=pd.Series([1,3,5,np.nan,6,8],index=dates).shift(2)print(s)print(df) 2013-01-01 NaN 2013-01-02 NaN 2013-01-03 1.0 2013-01-04 3.0 2013-01-05 5.0 2013-01-06 NaN Freq: D, dtype: float64 A B C D F 2013-01-01 0.000000 0.000000 0.804306 5 NaN 2013-01-02 -0.947881 0.482789 -0.044766 5 1.0 2013-01-03 0.089794 0.407933 -0.081971 5 2.0 2013-01-04 -0.671818 1.295661 -0.677348 5 3.0 2013-01-05 0.519066 -1.204134 1.747446 5 4.0 2013-01-06 -0.528972 -0.741428 0.454718 5 5.0 1df.sub(s,axis=&#x27;index&#x27;) # index 를 기준으로 했기 때문에, 값이 없는 부분은 nan 이 뜨고 값이 있는 부분은 그 부분 끼리 빼준다 broadcasting 적용 된 것 A B C D F 2013-01-01 NaN NaN NaN NaN NaN 2013-01-02 NaN NaN NaN NaN NaN 2013-01-03 -0.910206 -0.592067 -1.081971 4.0 1.0 2013-01-04 -3.671818 -1.704339 -3.677348 2.0 0.0 2013-01-05 -4.480934 -6.204134 -3.252554 0.0 -1.0 2013-01-06 NaN NaN NaN NaN NaN Apply(적용)12print(df)print(df.apply(np.cumsum)) # 축에 따라 밑으로 갈 수록 누적 합계 A B C D F 2013-01-01 0.000000 0.000000 0.804306 5 NaN 2013-01-02 -0.947881 0.482789 -0.044766 5 1.0 2013-01-03 0.089794 0.407933 -0.081971 5 2.0 2013-01-04 -0.671818 1.295661 -0.677348 5 3.0 2013-01-05 0.519066 -1.204134 1.747446 5 4.0 2013-01-06 -0.528972 -0.741428 0.454718 5 5.0 A B C D F 2013-01-01 0.000000 0.000000 0.804306 5 NaN 2013-01-02 -0.947881 0.482789 0.759541 10 1.0 2013-01-03 -0.858087 0.890722 0.677570 15 3.0 2013-01-04 -1.529906 2.186383 0.000222 20 6.0 2013-01-05 -1.010840 0.982249 1.747668 25 10.0 2013-01-06 -1.539811 0.240821 2.202386 30 15.0 lambda def로 굳이 함수를 명명하지 않고 apply 함수 뒤에 lambda를 이용하는 방법도 있다. 데이터프레임명.적용할 컬럼명.apply(lambda x:기능서술) 12print(df)print(df.apply(lambda x:x.max())) # 각열마다 최댓값 A B C D F 2013-01-01 0.000000 0.000000 0.804306 5 NaN 2013-01-02 -0.947881 0.482789 -0.044766 5 1.0 2013-01-03 0.089794 0.407933 -0.081971 5 2.0 2013-01-04 -0.671818 1.295661 -0.677348 5 3.0 2013-01-05 0.519066 -1.204134 1.747446 5 4.0 2013-01-06 -0.528972 -0.741428 0.454718 5 5.0 A 0.519066 B 1.295661 C 1.747446 D 5.000000 F 5.000000 dtype: float64 Histogramming(히스토그래밍)12s=pd.Series(np.random.randint(0,7,size=10)) #0부터 7사이의 값을 10개 랜덤s 0 2 1 6 2 2 3 3 4 6 5 1 6 1 7 1 8 3 9 1 dtype: int64 1s.value_counts() # 각 값의 갯수 카운팅 1 4 2 2 6 2 3 2 dtype: int64 String Methods12s = pd.Series([&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;Aaba&#x27;, &#x27;Baca&#x27;, np.nan, &#x27;CABA&#x27;, &#x27;dog&#x27;, &#x27;cat&#x27;])s 0 A 1 B 2 C 3 Aaba 4 Baca 5 NaN 6 CABA 7 dog 8 cat dtype: object 1s.str.lower() # s의 문자열을 다 소문자를 써라. 0 a 1 b 2 c 3 aaba 4 baca 5 NaN 6 caba 7 dog 8 cat dtype: object Merge Concat(연결) 12df=pd.DataFrame(np.random.randn(10,4)) #10행 4열 random 으로 만들어라df 0 1 2 3 0 1.262212 0.955071 0.203384 0.508407 1 0.512366 2.174993 -1.555680 0.617319 2 0.586218 0.729675 -0.328818 -1.401425 3 -1.025362 0.487188 -0.605979 -0.655267 4 1.446434 0.578147 0.249187 0.808614 5 1.827873 1.416959 -2.200127 -0.075029 6 -1.802936 -0.342006 0.971964 0.316691 7 -0.298966 1.571829 -1.589146 -0.240107 8 1.457950 -0.184842 -1.340462 -0.566541 9 -1.402115 1.613607 -0.019760 -1.038753 12pices=[df[:3],df[3:7],df[7:]]pices [ 0 1 2 3 0 1.262212 0.955071 0.203384 0.508407 1 0.512366 2.174993 -1.555680 0.617319 2 0.586218 0.729675 -0.328818 -1.401425, 0 1 2 3 3 -1.025362 0.487188 -0.605979 -0.655267 4 1.446434 0.578147 0.249187 0.808614 5 1.827873 1.416959 -2.200127 -0.075029 6 -1.802936 -0.342006 0.971964 0.316691, 0 1 2 3 7 -0.298966 1.571829 -1.589146 -0.240107 8 1.457950 -0.184842 -1.340462 -0.566541 9 -1.402115 1.613607 -0.019760 -1.038753] 1pd.concat(pices) # 축에따라 위 아래 붙이는 함수. 3개의 리스트로 이루어져있던 함수를 합침. 0 1 2 3 0 1.262212 0.955071 0.203384 0.508407 1 0.512366 2.174993 -1.555680 0.617319 2 0.586218 0.729675 -0.328818 -1.401425 3 -1.025362 0.487188 -0.605979 -0.655267 4 1.446434 0.578147 0.249187 0.808614 5 1.827873 1.416959 -2.200127 -0.075029 6 -1.802936 -0.342006 0.971964 0.316691 7 -0.298966 1.571829 -1.589146 -0.240107 8 1.457950 -0.184842 -1.340462 -0.566541 9 -1.402115 1.613607 -0.019760 -1.038753 join(결합) SQL 방식으로 병합합니다. 1234left=pd.DataFrame(&#123;&#x27;key&#x27;:[&#x27;foo&#x27;,&#x27;foo&#x27;],&#x27;lval&#x27;:[1,2]&#125;)right=pd.DataFrame(&#123;&#x27;key&#x27;:[&#x27;foo&#x27;,&#x27;foo&#x27;],&#x27;lval&#x27;:[4,5]&#125;)print(left)print(right) key lval 0 foo 1 1 foo 2 key lval 0 foo 4 1 foo 5 1pd.merge(left,right,on=&#x27;key&#x27;) #on =&gt; 기준 컬럼명을 써준다. key lval_x lval_y 0 foo 1 4 1 foo 1 5 2 foo 2 4 3 foo 2 5 12345left = pd.DataFrame(&#123;&#x27;key&#x27; : [&#x27;foo&#x27;, &#x27;bar&#x27;], &#x27;lval&#x27; : [1, 2]&#125;)right = pd.DataFrame(&#123;&#x27;key&#x27;: [&#x27;foo&#x27;, &#x27;bar&#x27;], &#x27;rval&#x27;: [4, 5]&#125;)print(left)print(right)print(pd.merge(left, right, on= &#x27;key&#x27;)) key lval 0 foo 1 1 bar 2 key rval 0 foo 4 1 bar 5 key lval rval 0 foo 1 4 1 bar 2 5 Append(추가) 12df = pd.DataFrame(np.random.randn(8, 4), columns=[&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;])df A B C D 0 -1.956503 0.016695 -1.376558 0.882448 1 -3.313167 -0.644514 0.439943 -2.580286 2 0.575209 0.129929 1.329659 -0.101877 3 0.332593 -0.398031 1.001786 0.371959 4 -0.305303 -0.695755 -0.817616 0.965844 5 0.599091 -0.984070 -1.422782 -2.028921 6 1.295195 -0.209816 2.010686 0.409705 7 0.268063 2.963411 1.338692 -0.083000 12s=df.iloc[3]s A 0.332593 B -0.398031 C 1.001786 D 0.371959 Name: 3, dtype: float64 12print(df)print(df.append(s,ignore_index=True)) A B C D 0 -1.956503 0.016695 -1.376558 0.882448 1 -3.313167 -0.644514 0.439943 -2.580286 2 0.575209 0.129929 1.329659 -0.101877 3 0.332593 -0.398031 1.001786 0.371959 4 -0.305303 -0.695755 -0.817616 0.965844 5 0.599091 -0.984070 -1.422782 -2.028921 6 1.295195 -0.209816 2.010686 0.409705 7 0.268063 2.963411 1.338692 -0.083000 A B C D 0 -1.956503 0.016695 -1.376558 0.882448 1 -3.313167 -0.644514 0.439943 -2.580286 2 0.575209 0.129929 1.329659 -0.101877 3 0.332593 -0.398031 1.001786 0.371959 4 -0.305303 -0.695755 -0.817616 0.965844 5 0.599091 -0.984070 -1.422782 -2.028921 6 1.295195 -0.209816 2.010686 0.409705 7 0.268063 2.963411 1.338692 -0.083000 8 0.332593 -0.398031 1.001786 0.371959 Grouping(그룹화) 그룹화는 다음 단계중 하나 이상을 포함하는 과정을 가리킵니다. 몇몇 기준에 따라 여러그룹으로 데이터를 분할(splitting) 각 그룹에 독립적으로 함수를 적용(applying) 결과물들을 하나의 데이터 구조로 결합(combining) 12345678df = pd.DataFrame( &#123; &#x27;A&#x27; : [&#x27;foo&#x27;, &#x27;bar&#x27;, &#x27;foo&#x27;, &#x27;bar&#x27;, &#x27;foo&#x27;, &#x27;bar&#x27;, &#x27;foo&#x27;, &#x27;foo&#x27;], &#x27;B&#x27; : [&#x27;one&#x27;, &#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;, &#x27;two&#x27;, &#x27;two&#x27;, &#x27;one&#x27;, &#x27;three&#x27;], &#x27;C&#x27; : np.random.randn(8), &#x27;D&#x27; : np.random.randn(8) &#125;)df A B C D 0 foo one 2.320590 1.009107 1 bar one -0.273917 -0.749687 2 foo two -0.817982 -0.413826 3 bar three 0.810967 0.348991 4 foo two 1.299073 -0.947616 5 bar two 1.743033 -1.497056 6 foo one 0.626893 -0.236820 7 foo three 2.109443 0.383633 123print(df.groupby(&#x27;A&#x27;).sum()) # A열을 기준으로 나머지 열의 값 합계 , B열은 문자열이라 제외print(df.groupby([&#x27;A&#x27;,&#x27;B&#x27;]).sum()) #A-B기준으로 합계 C D A bar 2.280084 -1.897753 foo 5.538016 -0.205523 C D A B bar one -0.273917 -0.749687 three 0.810967 0.348991 two 1.743033 -1.497056 foo one 2.947482 0.772287 three 2.109443 0.383633 two 0.481090 -1.361442 #Reshaping (변형) Stack(스택) 1tuples=list(zip(*[]))","categories":[{"name":"데이터분석","slug":"데이터분석","permalink":"https://kimyoungjae777.github.io/categories/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B6%84%EC%84%9D/"}],"tags":[],"author":"Young Jae Kim"},{"title":"pandas 의 broadcastiong ","slug":"broadcasting","date":"2022-03-16T00:00:00.000Z","updated":"2023-04-14T14:29:10.442Z","comments":true,"path":"2022/03/16/broadcasting/","link":"","permalink":"https://kimyoungjae777.github.io/2022/03/16/broadcasting/","excerpt":"","text":"판다스의 broadcastiong참조:(16) broadcastiong과 연산 | 판다스(pandas) 기본강의 #03 - YouTube 넘파이의 연산. →행과 열이 같아야 연산이 가능하다 3x3 행렬과 1x3 행렬의 곱이 위의 처럼 연산이 같아지는갓 1 행이 2행과 3행과 같다고 생각하고 하는 연산을 broadcastiong 라고 한다 ★ numpy 와 pandas 의 차이 ★ numpy 는 저 행렬들의 자리가 중요하지만, pandas 는 index 와 columns 를 기준으로 라벨링을 기준으로 연산을 해준다. 라벨이 전부 다르기 때문에 전무 NaN 값이 나온다 이게 default 고 , 축 바꿔서 실행할 수 있다. 1차원이기 때문에 전치 행렬 개념이 없다. axis&#x3D;0 일때 # 실습","categories":[{"name":"데이터분석","slug":"데이터분석","permalink":"https://kimyoungjae777.github.io/categories/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B6%84%EC%84%9D/"}],"tags":[],"author":"Young Jae Kim"},{"title":"loc 와 iloc 의 차이 ","slug":"loc_iloc","date":"2022-03-16T00:00:00.000Z","updated":"2023-04-14T14:29:10.448Z","comments":true,"path":"2022/03/16/loc_iloc/","link":"","permalink":"https://kimyoungjae777.github.io/2022/03/16/loc_iloc/","excerpt":"","text":"loc 와 iloc 의 차이 loc:label 을 통해서 값 찾는다 iloc:integer position 을 통해 값을 찾는다 문법 공통점:df.loc[[행],[열]] loc 의 경우 12df1.loc[:,2,[&#x27;Survived&#x27;, &#x27;Pclass&#x27;,&#x27;Name&#x27;]] iloc 의 경우 1df1.iloc[:2,1:4]","categories":[{"name":"데이터분석","slug":"데이터분석","permalink":"https://kimyoungjae777.github.io/categories/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B6%84%EC%84%9D/"}],"tags":[],"author":"Young Jae Kim"},{"title":"깃 블로그와 연동하기","slug":"make_blog","date":"2022-03-16T00:00:00.000Z","updated":"2023-04-14T14:29:10.449Z","comments":true,"path":"2022/03/16/make_blog/","link":"","permalink":"https://kimyoungjae777.github.io/2022/03/16/make_blog/","excerpt":"","text":"깃허브 블로그 만들기1.깃과 로컬 연동시켜주기 1.마우스 우클릭으로 git bash 를 열어주고, hexo 파일을 만들어준다 12hexo init youngjae 이 이후에 깃허브에 들어가서 youngjae 와 이름이 같은 레퍼지토리를 만들어 줍니다. 2.이제 로컬의 youngjae와 git의 youngjae 를 연동시켜 주어야 합니다. 로컬에 있는 my blog를 파이참으로 실행 시켜 줍니다. 파이참으로 실행시킨뒤 필요한 패키지를 깔아줍니다 $ npm install $ npm install hexo-server –save $ npm install hexo-deployer-git –save 이제 명령창에 이 명령어들을 복사,붙여넣기를 해줍니다. 그러면 창이 이렇게 변하게 됩니다!! 이제 그러면 로컬에 있는 youngjae 폴더의 모든 파일들을 깃허브에 연동하여 업로드 해 보겠습니다 123git add . # 모든 파일을 업로드 한다git commit -m &quot;upload&quot; git push #이제 다 준비 되었으니 다 올려라 !! 그러면 이렇게 깃허브와 연동되어 로컬에 있는 모든 파일이 올라가게 됩니다 !! 2.hexo 로 웹페이지 만들기 cosfig.yml 로 들어가서 tilte 도 조정을 해주고, url도 조정을 해줍니다. 한번 홈페이지를 로컬에서 열어주어 볼까요? hexo generate 와 hexo server 명령어를 쳐줍니다. 웹을 생성해주고 서버로 url 로 넘어갈수 있는 명령어에요!! 이렇게 웹사이트가 생성 되었네요 !! 이제는 이것을 git으로 연동해 배포해주겠습니다. 맨 아래 Deployment 부분에 이렇게 바꾸어줍니다 여기서 !! 깃허브 레퍼지토리에 [kimyoungjae777.github.io](http://kimyoungjae777.github.io) 이름으로 된 레퍼지토리를 새로 만들어줍니다. 여기에 연동을 시켜줄 거니까요!! hexo generate 로 웹을 생성시켜주고 hexo deploy 로 배포를 해줍니다. 이렇게 되면, 웹페이지가 배포 되면서 커뮤니케이션을 할 수 있게 됩니다. 3.웹의 테마 설정하기 (이카루스) 이카루스 테마를 설정하기 위해 이카루스 깔기 테마 바꿔 주기. 하지만 에러가 발생하였다.. 에러 해결!! 이렇게 테마가 바뀐것을 볼 수가 있다. !!","categories":[{"name":"Development","slug":"Development","permalink":"https://kimyoungjae777.github.io/categories/Development/"},{"name":"gitBlog","slug":"Development/gitBlog","permalink":"https://kimyoungjae777.github.io/categories/Development/gitBlog/"}],"tags":[{"name":"Development","slug":"Development","permalink":"https://kimyoungjae777.github.io/tags/Development/"},{"name":"gitBlog","slug":"gitBlog","permalink":"https://kimyoungjae777.github.io/tags/gitBlog/"}],"author":"Young Jae Kim"},{"title":"정규화 StandardScaler","slug":"Standard s 65363","date":"2022-03-15T00:00:00.000Z","updated":"2023-04-14T14:29:10.432Z","comments":true,"path":"2022/03/15/Standard s 65363/","link":"","permalink":"https://kimyoungjae777.github.io/2022/03/15/Standard%20s%2065363/","excerpt":"","text":"images&#x2F;make_blog Standard scaler() 정규화 모든 Feature 들이 스케일(범위) 가 같은 것 은 아니기 때문에 전처리 할때는 , 스케일들을 정규화 시켜주는 것이 필요하다. → 정규화를 시켜주어야 스케일링이 적용되며 서로 스케일이 다름으로써 나오는 오류를 없애줄 수 있는 것이다. 원핫 인코딩 되어 있는 데이터나, 숫자에 통계학적 의미가 없는 데이터들은 스케일링 해줄 필요 없다 스케일링은 각 컬럼별로 해주는 것이 좋다, 다 같이 해주면 평균이나 이러한 것들이 엉켜서 버그를 일으킬 수 있기 때문이다. 123456789101112131415161718import pandas as pdfrom pandas import DataFrame as dfimport numpy as npfrom sklearn.preprocessing import StandardScalerdf1=df(data=&#123;&#x27;height&#x27;:[170,160,180,170,175,180,160,165,186,172], &#x27;weight&#x27;:[65,55,70,60,62,72,60,58,100,67], &#x27;favor&#x27;:[1,0,1,0,0,1,1,1,0,1]&#125;)df1.head()# 스케일링 해줄때 각 컬럼별 array 로 변환해 주어야 하기 때문에height_df=df1[&#x27;height&#x27;]weight_df=df1[&#x27;weight&#x27;]favor_df=df1[&#x27;favor&#x27;]height_df=np.array(height_df).reshape(-1,1)weight_df=np.array(weight_df).reshape(-1,1)favor_df=np.array(favor_df).reshape(-1,1) 123scaling_height=StandardScaler().fit_transform(height_df)scaling_weight=StandardScaler().fit_transform(weight_df)scaling_height # 스케일링 된 것을 볼 수 있다","categories":[{"name":"데이터분석","slug":"데이터분석","permalink":"https://kimyoungjae777.github.io/categories/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B6%84%EC%84%9D/"}],"tags":[],"author":"Young Jae Kim"},{"title":"Support vector machine","slug":"Support ve 33593","date":"2022-03-15T00:00:00.000Z","updated":"2023-04-14T14:29:10.433Z","comments":true,"path":"2022/03/15/Support ve 33593/","link":"","permalink":"https://kimyoungjae777.github.io/2022/03/15/Support%20ve%2033593/","excerpt":"","text":"Support vector machine출처:한국공학대학교 경영학과 강지훈 교수님 강의. 中 분류에 대한 수적 표현에 대해 먼저 알아 보자. 학습 데이터 X(독립변수),Y(종속변수)가 있을 때 (i&#x3D;1,2,3,4,5 ….데이터의 갯수) Y⇒{-1,1} (두 개의 클래스를 의미) ⇒ 경우에 따라서, 클래스를 1과 -1 로 나눔 Y(정답) * F(x)(예측한 정답) &gt;0 라는 것은 제대로 분류된 형태 ( 같은 부호끼리 곱하면 양수인 경우니까) 선형 분할(Linear Classifier) f(x)&#x3D; W transpose X + b (선형조합, 각각의 항들이 더하기로 이루어진 조합.) 선형분할은 직선으로 나누는 것 (2차원이건 3차원이건 그 이상이건 상관 없음) b(bias) Y 절편을 의미 W는 직선의 기울기 선형 분할 가능 더 나은(최적) 분류를 위한 초평면(Hyperplane)→선 보다 더 큰 차원 어떤 선이 좋은 판별선일까?최적화→좋은 것 을 극대화 시키고 나쁜 것 을 극소화 시키는 것 분류에서의 최적화→ 잘 안나뉘는것 , 잘 나뉘는 것 나중에 Testing data 를 돌렸을때, 가장 좋게 나누는 직선은 절반이다. 왜냐면 Test data 가 어떻게 들어올지 모르는 것 이기때문에 , 아슬아슬하게 나눈것 보다, 확실히 절반으로 나누는것이 좋다. 초평면 찾기. 2개의 class가 선형으로 구분 가능한 경우, class1과 class2를 구분할 수 있는 선의 종류는 무수히 많음 두 영역을 어떻게 나누는 것이 가장 적절한가? 최적의 분할 초평면 찾기. c는 선형분할의 각 클래스별 거리 각 클래스별 거리를 합친것을 우리는 Margin 이라고 한다. Margin&#x3D;2c를 최대화 하는, w T x +b&#x3D;0 의 직선을 찾아야 하는것 이다. Marign 을 최대화 시키는 초평면이 최적 “Learning Theory” 에 따르면, Marigin을 최대화 시키는 초평면이 일반화 오류가 가장 낮게 나타남(Test data 에서도 좋은 점수가 나온다) Margin:초평면과 가장 근접한 각 클래스 관측치와의 거리의 합. 기하학적인 Margin Margin 수식 유도 1(일반적인 방법) 마진 수식 유도 2(고등학교때 배운 방법 응용.점과 선 사이의 거리 거리 d 가 2개이니까 2&#x2F;||W|| 마진을 최대화 해보자 .(최적화) ||w|| 가 분모에 있기 때문에 결국 ||w|| 를 최소화 해주는것 이 2&#x2F;||w|| 를 최대화 해주는거랑 같다고 할 수 있다 우리는 결국 w 값을 최소화 시켜주는것이 목적이기 때문에 제곱을 취해주든 상수를 곱해주는 상관이 없다 마진을 최대화 해보자 .(최적화) s.t→제약사항⇒ Yi(실제답) * (w*Xi +b)→모델답) 이 1보다 커야 한다. ⇒ 올바르게 분류가 되는 조건. convex Optimization &#x3D; 최적의 해가 항상 1개 존재하는 함수 Quadraitc(2차) 목적함수와 선형 제약조건 (+로 변수 조합) 이 존재 마진을 최대화 해보자 .(최적화) Lagrange Multiplier(수학적 기법) ⇒ 제약조건을 최적화조건에 녹여버리는 기법. 라그랑쥬를 다 풀고 나면 판별식이 나온다.-Xi tranpose X ( 학습데이터와 분류할 데이터의 내적) SVM(지지벡터머신)의 의미 정리 판별식에 서포트벡터만 사용하기 때문에 아웃라이어에 대한 영향을 안 받음(KKT 조건으로 걸러냄) KNN 또한 이웃을 확인하는 개수인 K의 한계가 있어서 어느 elbow point 를 지나치면 정확도가 떨어진다. → 비슷한 원리 ⇒ svm 또한 분류를 유효하게 하기위해서 support verctor 만 이용해준다. 만약에 선형으로 완벽히 나눠지지 않는 데이터라면 테스트데이터 에게는 위의 모델 보다 아래 모델이 더 좋을 것 으로 보인다. 하지만 SVM 의 제약조건에는 트레인데이터가 완벽하게 나누어져야 한다는 제약 조건이 걸려있다. 어떻게 하면 좋을까? . 여유를 주자(Slack Variable for “Soft Margin”) error ⇒ 잘못 분류할 확율 Soft Margin SVM Non-linear SVM 커널의 종류 커널의 종류에 따라 분할 경계","categories":[{"name":"Machinelearning","slug":"Machinelearning","permalink":"https://kimyoungjae777.github.io/categories/Machinelearning/"},{"name":"알고리즘","slug":"Machinelearning/알고리즘","permalink":"https://kimyoungjae777.github.io/categories/Machinelearning/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"}],"tags":[{"name":"Machinelearning","slug":"Machinelearning","permalink":"https://kimyoungjae777.github.io/tags/Machinelearning/"},{"name":"알고리즘","slug":"알고리즘","permalink":"https://kimyoungjae777.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"}],"author":"Young Jae Kim"},{"title":"Time series data (시계열 데이터)","slug":"time series","date":"2022-03-15T00:00:00.000Z","updated":"2023-04-14T14:29:10.461Z","comments":true,"path":"2022/03/15/time series/","link":"","permalink":"https://kimyoungjae777.github.io/2022/03/15/time%20series/","excerpt":"","text":"시계열 데이터참조:네이버 지식백과 일반적으로 어떤 양의 관측결과를 일정한 기준에 따라 계열로 정리한 것을 통계계열이라고 한다. 어떤 관측치 또는 통계량의 변화를 시간의 움직임에 따라서 포착하고 이것을 계열화하였을 때, 이와같은 통계계열을 시계열이라고 한다. 이러한 경우의 관측결과 x는 시간 t에 따라서 변동하는 양이므로 그 시계열은 {xt}로 표시된다. 예를들면 한 나라의 경제성장을 알기 위한 실질국민 총 생산지수에 관한 통계도표는 연도를 시간이라고 생각하였을 때의 시계열의 도표이다","categories":[{"name":"Machinelearning","slug":"Machinelearning","permalink":"https://kimyoungjae777.github.io/categories/Machinelearning/"},{"name":"통계","slug":"Machinelearning/통계","permalink":"https://kimyoungjae777.github.io/categories/Machinelearning/%ED%86%B5%EA%B3%84/"}],"tags":[{"name":"Machinelearning","slug":"Machinelearning","permalink":"https://kimyoungjae777.github.io/tags/Machinelearning/"},{"name":"통계","slug":"통계","permalink":"https://kimyoungjae777.github.io/tags/%ED%86%B5%EA%B3%84/"}],"author":"Young Jae Kim"},{"title":"통계 전반적인 부분 필사","slug":"statics","date":"2022-03-15T00:00:00.000Z","updated":"2023-04-14T14:29:10.458Z","comments":true,"path":"2022/03/15/statics/","link":"","permalink":"https://kimyoungjae777.github.io/2022/03/15/statics/","excerpt":"","text":"분석방법통계는 수량 데이터에서 다양한 방법으로 새로운 사실들을 찾아내는 학문입니다. 통계를 알아야 하는 이유는 사실을 확인하고,새로운 내용을 알아내기 위해서 입니다. 빅데이터를 분석할 때 기초적인 통계 지식을 아느냐,모르느냐에 따라 분석능력에 큰 차이가 생깁니다. 통계지식이 없으면 심각한 오류를 범할 수 있습니다. 실제로는 두 집단의 평균에서 차이가 없는데도 있다고 차이가 있다고 판단하는 경우가 대표적인 오류입니다. 통계에는 크게 두 종류가 있습니다. 1)기술통계분산값이 크다-&gt;평균으로부터 멀어진 개별적인 데이터가 많다분산값이 작다-&lt;평균주위에 개별적인 데이터가 적다빅데이터 분석에서는 기본적으로 알아야 하는 값들이 있습니다.평균,최솟값,최댓값,중앙값과 같이 데이터의 특징을 알려주는 값들입니다. 이런 값들은 기술통계 라고합니다. 데이터의 특징을 서술한다는 의미입니다. 기술통계는 사실확인에 해당됩니다. 2)추론통계변수간의 관계를 파악하고, 이를 토대로 변수간의 인과관계나 새로운 사실들을 밝혀내는 것을 추론통계 라고 합니다.데이터 분석에서 하는 추론통계에는 평균 차이 검정, 교차분석,상관관계 분석, 회귀분석 등이 있습니다 1)평균차이검정집단별로 평균의 차이가 실제로 있는가를 검정하는 것입니다. 한 고등학교에서 3학년 학생들이 국어 시험을 보았는데,남학생 집단의 평균은 82.1점이고, 여학생 집단 평균은 82.3점 입니다. 여학생 집단이 남학생 집단보다 0.2점 높습니다. 그렇다고 여학생 집단의 성적이 남학생 집단보다 높다고 단정할 수 있을까요? 과거에는 남학생 집단의 평균이 여학생 집단의 평균보다 높은 적이 있었습니다. 그렇다면 이번에는 우연히 여학생 집단의 평균이 높았을 수도 있습니다. 때문에 이번 성적 결과가 “의미 있다”, 즉, “여학생 집단의 평균성적이 남학생 집단보다 일반적으로 높다” 고 결론을 내리기 위해서는 먼저 이번 성적의 결과가 우연하게 발생한 것이 아니라는 것을 통계적으로 검정해야 합니다. 2)교차분석범주형 변수로 구성된 집단들의 관련성을 검정하는 통계 분석입니다. 교차분석은 카이제곱검정,카이스퀘어검정,독립성 검정이라고도 합니다한 아ㅏ트 단지에 100세대가 살고 있습니다. 집 크기는 소형이 50세대,대형이 50세대입니다. 이 단지의 TV 크기는 소형,대형 등 두 종류입니다. 집이 크면 대형 TV를 보유하고, 집이 작으면 소형 TV 를 보유하는지 , 즉 집의 크기와 TV 크기가 관계가 있는지를 통계적으로 분석하는 것이 교차 분석 검정입니다. 아파트 크기와 TV 크기는 모두 범주형 이어서 평균차이 검정을 할 수 없습니다. 분석결과는 관계가 있다, 없다 등 2가지입니다. 확률적으로는 이 단지의 TV 보유 상황은 소형 50대, 대형50대인 것으로 생각할 수 있습니다. 그런데 90세대가 대형TV를 보유하고, 10세대가 소형 TV를 보유하고 있다면, 아파트 크기와 TV 크기는 관계가 없습니다. 이런 경우는 “아파트 크기와 TV 크기는 독립적이다” 또는 “아파트 크기에 따라 TV 크기의 차이는 없다” 고 합니다. 그러나 55세대가 대형 TV를 보유하고 있고, 45세대가 소형TV를 보유하고 있으면 아파트 크기와 TV 크기는 관계가 있다고 추론할 수 있습니다. 이런경우 “아파트 크기와 TV 크기는 독립적이지 않다” 또는 “아파트 크기에 따라서 TV 크기는 차이가 있다” 고 합니다. 교차분석의 검정의 목적은 두 변수 사이에 관계가 있다는 것을 알아보는 것 입니다. 3)상관관계 분석상관관계분석은 변수 간의 상관관계를 알아보는 것입니다. 상관관계는 변수간의 연관성입니다. 한 변수가 변화하면 다른 변수도 변화하는 관계입니다. 집합에서 여러 집단들이 교차해 있는 공집합의 관계를 생각하면 됩니다. 상관관계에서는 관계의 강도와 방향이 중요합니다. 강도는 한 변수가 변화할 떄 다른변수가 변화하는 정도입니다. 방향은 한 변수가 변화할 때 다른 변수가 같은방향으로 변화하는지, 반대방향으로 변화하는지를 의미합니다. 변화의 강도와 방향을 나타나는 계수가 상관계수(r)입니다. 상관계수는 -1부터 1사이에 있습니다. 수치가 클수록 영향을 주는 강도가 큽니다 + 정의관계 - 부의관계 또는 역의관계에 있는 것을 의미합니다. 상관계수가 0.3 이면, 한 변수가 1단위 변화할 때 다른 변수가 0.3만큼 같은 방향으로 변화하는 것을 말합니다. 상관관계 계수 -1&lt;r&lt;1상관관계가 절대값 0.7 이상이면 높은관계 0.40.7 미만이면 다소 높은 관계 0.20.4 이면 낮은 관계에 있다고 봅니다. 0.2 미만이면 거의 없다고 해석합니다 (4)회귀분석상관관계로는 변수들의 관계를 알 수는 있지만, 인과관계는 알 수 없습니다. 인과관계는 원인과 결과의 관계입니다. 한 변수가 다른 변수에 영향을 주는 것을 말합니다. 영향을 주는 변수는 독립변수 이고, 영향을 받는 변수는 종속변수 입니다. 독립변수와 종속변수 간의 인과관계를 분석하는 통계적 방법을 회귀 분석이라고 합니다 “월급이 증가하면 외식횟수가 늘어날 것” 이라고 가정하면 월급은 독립변수이고, 외식횟수는 종속변수입니다. 월급의 증감은 외식횟수에 미치는 영향을 확률적으로 분석하는 것이 회귀분석입니다. 사회과학에서 회귀분석은 통계 분석의 꽃이라고 불릴정도로 매우 중요한 통계분석입니다. 회귀분에서 독립변수가 1개이면 단순회귀분석, 2개이상이면 다중회귀분석이라고 합니다. 단순회귀분석은 1차함수 y&#x3D;a+bx 에서 b를 찾아내는 것 입니다. x가 1증가하면, y는 b만큼 증가합니다. b를 회귀계수라고 합니다. x는 독립변수, y는 종속변수 a는 상수입니다.회귀분석에서 a는 저련이라고 하는데, 통계적인 의미는 없습니다. 다중회귀분석은 종속변수는 1개이며 독립변수가 복수인 경우입니다. 복수의 독립변수들이 종속변수에 영향을 주는 정도를 분석하는 겁니다. 단순회귀분석&#x3D;y&#x3D;a+bx종속회귀분석&#x3D;y&#x3D;a+bx1+bx2통계검정(1)가설가설은 어떤 현상을 설명하기 위해서 가정하는 명제입니다.증명되지 않은 추정입니다. 가설에는 귀무가설과 대립가설이 있습니다. 귀무가설은 설정한 가설이 맞을 확율이 극히 적어서 처음부터 기각될 것으로 예상되는 가설입니다. 영가설 이라고도 합니다. 대립가설은 연구자가 검정하고자 하는 가설입니다. 통계 검정은 통계적인 방법을 이용해서 대립가설이 맞는가를 검정하는 것입니다. 두 집단의 평균 차이가 있는가를 알아보려 합니다. 평균 차이가 있는지를 검정하는 것이기 떄문에 귀무가설은 ‘평균 차이가 있다’ 입니다. H0(귀무가설):두 집단의 평균 차이가 없다H1(대립가설):두 집단의 평균 차이가 있다2)유의수준가설검정의 결과는 유의수준에 의해 결정됩니다. 유의수준은 귀무가설이 맞는데도 대립가설을 채택할 확률입니다. 즉 오류를 범할 확률입니다. 차이가 없느넫도 있다고 할 확률입니다. 통계 분석에서는 P-VALUE(P값)로 제시됩니다. P값이 0.01이라면 오류를 범할 확률이 1%라는 의미입니다. 오류가 없는 것이 가장 좋겠지만, 현실적으로 오류가 없다는 것은 거의 불가능합니다. 통계에서도 오류가 있기 마련이어서 어느정도의 오류는 인정할 수밖에 없습니다. 그래서 허용할 수 있는 오류범위를 정하게 됩니다 유의수준 5%는 오류를 5%까지 허용하겠다는 으미입니다. 화살 100발을 쏘는 경우 유의수준 5%는 과녁을 벗어나는 화살이 5발 이내이면 합격한 것으로 보는 것입니다. 화살 1000발을 쏘면 50발 이내입니다. 허용하는 유의수준의 범위와 정확성은 반대의 개념입니다. 유의수준의 범위가 넓으면 연구결과를 얻기가 쉽지만 결과의 정확성이 떨어지고, 너무 좁으면 결과를 얻기 어렵습니다. 100점 만점 시험에서 90점 이상을 합격으로 할 떄와 80점이상을 합격으로 할때 합격자의 부노와 질적수준은 크게 달라집니다 90점 이상으로 하면 합격자의 평균점수는 높지만 합격자 수가 적습니다. 80점 이상으로 하면 합격자 수는 증가하지만 합격자의 평균점수는 낮아집니다. 가설검정에서 인정하는 유의수준에는 5%,1%,0.1%등 세 종류가 있습니다. 사회과학에서는 5%까지 인정합니다. 그러나 정확성이 많이 요구되는 자연과학이나 의학에서는 유의수준의 허용범위가 더욱 좁아집니다. 통계 분석을 하면 결과물에는 유의수준(P-VALUE)이 적혀 있습니다. 통계 분석 결과를 해석할 떄는 먼저 유의수준이 0.05 이내인가를 보고, 결과가 통계적으로 유의미한지를 판단해야 합니다. 유의수준이 0.05 이상인데도 결과가 유의미하다고 해석되면 매우 심각한 오류입니다. 유의수준의 반대 개념은 신뢰수준 입니다. 신뢰할 수 있는 범위를 의미합니다. 유의수준 5% 이내라고 하면 신뢰수준은 95%입니다. 척도척도(scale)는 측정도구이며,수치로 표시됩니다. 척도에는 명목척도,서열척도,등간척도,비율척도 등 네 종류가 있습니다. 척도의 종류에 따라 통계분석이 가능하거나 불가능하기 때문에 분석하기 전에 척도의 종류를 파악해야합니다 명목척도:측정대상의 특성이나 범주를 구분하는 수치입니다. 운동선수의 번호를 생각하면 쉽습니다. 번호는 특정 선수를 의미합니다. 성을 분류할 때 통상 남자를 1번 여자를 2번으로 분류하는 것과 같이 결혼유무,종교,인종,지역,계절 등을 표시할 때도 이용됩니다. 산술연산을 할 수 없습니다. 서열척도:계급,사회계층,자격등급 등과 같이 측정대상의 등급순위를 나타내는 척도 입니다. 척도 간의 거리나 간격은 나타내지 않습니다. 산술연산을 할 수 없습니다. 등간척도:측정대상을 일정한 간격으로 구분한 척도입니다. 서열뿐만 아니라 거리와 간격도 표시합니다. 온도,학력,시험점수 등입니다. 덧셈과 뺄셈이 가능합니다. 비율척도:측정대상을 비율로 나타낼 수 있는 척도입니다. 연령,무게 등입니다. 모든 수로 측정할 수 있어 4칙연산이 가능합니다. 통계분석 사례1)두 집단의 평균 차이 검정남녀 등 두 딥단의 평균 차이를 분석할 때는 독립표본 t검정을 합니다. R에서는 내장된 t.test()함수로 합니다. 독립변수는 명목척도이며, 종속변수는 등간척도 또는 비율척도 이어야 합니다. t.test() 함수를 쓰는 방식은 2가지가 있습니다. 방법1) t.test(data&#x3D;데이터세트,종속변수~독립변수)방법2) t.test(데이터세트$종속변수~데이터세트$독립변수)예제를 통해 알아보자예제파일인 mpg1.csv의 trans 변수에는 기어변속방법으로 auto 와 manaual 등 두 방식이 있습니다.두 방식에 따라 cty평균이 통계적으로 유의미한 차이가 있는가를 알아보겠습니다. cty는 도시에서 1갤런당 달리는 거리입니다. 독립변수는 trans 이며, 종속변수는 cty입니다. 가설은 다음과 같이 설정합니다 귀무가설:auto와 manual의 cty 평균은 차이가 없다.대립가설:auto와 manual의 cty 평균은 차이가 있다.12mpg1&lt;-read.csv(&quot;mpg1.csv&quot;,stringsAsFactors = FALSE)t.test(mpg1$cty~mpg1$trans) 1234567891011## ## Welch Two Sample t-test## ## data: mpg1$cty by mpg1$trans## t = -4.5375, df = 132.32, p-value = 1.263e-05## alternative hypothesis: true difference in means between group auto and group manual is not equal to 0## 95 percent confidence interval:## -3.887311 -1.527033## sample estimates:## mean in group auto mean in group manual ## 15.96815 18.67532 t.test 평균 차이 검정을 해석해 보자면 p-vaue가 1.263&#x2F;100000 값이 나왔으므로, 95 percent confidence interval 이 뜻은 신뢰수준이 95% 라는 뜻이고, 그렇게 되면 유의수준이 5% 이기때문에, 0.05보다 매우 작기 때문에 유의수준 허용조건을 충족 시켰다. alternative hypothesis: true difference in means between group auto and group manual is not equal to 0 이 뜻은 대립가설:평균 차이가 있다 라는 뜻 입니다.sample estimates 를 보면 auto의 평균이 15.96 manual 의 평균이 18.675 인것을 보아도 알 수 있다.결론을 쓸때는 “cty 평균거리는 자동식이 15.97마일, 수동식이 18.68마일이다. 유의 수준(p)이 0.05 보다 작아서 통계적으로 유의미한 차이가 있기 때문에 수동식 평균이 자동식의 평균보다, 약2.7마일 길다고 할 수 있다” 고 하면 됩니다. ‘길다’ 라고 단정적으로 쓰지 않고 ‘길다고 할 수 있다’라고 추론식으로 쓴 것은 확률을 토대로 한 추론분석이기 때문입니다. 만약 p-value가 .05보다 크면 “유의수준이 0.05 보다 크기 때문에 자동식과 수동식의 평균은 통계적으로 유의미한 차이가 없다” 라고 쓰면 됩니다. 2)교차분석교차분석은 범주형 변수들이 관계가 있다는 것을 입증하는 것입니다. 평균의 차이가 아니라,비율에 차이가 있는지를 검정합니다.교차분석 검정은 R의 chisq.test() 함수로 합니다. 교차분석 나중에 다시 해보기귀무가설:trans 에 따라서 drv의 차이가 없다.대립가설:trans 에 따라서 drv의 차이가 있다.우선 table() 함수와 prop.table() 함수로 교차분석을 해서 trans에 따른 drv의 빈도와 비율을 알아보아야한다. 상관관계분석상관관계 분석은 R에 내장되어 있는 cor.test() 함수로 합니다. mpg1 에는 cty 와 hwy가 있습니다 cty는 도시에서 1갤런당 달리는 거리이고 hwy는 고속도로에서 1갤런당 달리는 거리입니다. cty가 길면 hwy도 길 럿이라고 생각할 수 있습니다. 이 가설을 검정해 보겠습니다. 검정하려는 가설은 cty와 hwy는 서로 상관관계가 있다는 것이기 때문에 이것이 대립가설입니다. 귀무가설은 상관관계가 없다는 것 입니다. 귀무가설:cty와 hwy 는 상관관계가 없다.대립가설:cty와 hwy 는 상관관계가 있다.12mpg1&lt;-read.csv(&quot;mpg1.csv&quot;,stringsAsFactors = FALSE)cor.test(mpg1$cty,mpg1$hwy) 1234567891011## ## Pearson&#x27;s product-moment correlation## ## data: mpg1$cty and mpg1$hwy## t = 49.585, df = 232, p-value &lt; 2.2e-16## alternative hypothesis: true correlation is not equal to 0## 95 percent confidence interval:## 0.9433129 0.9657663## sample estimates:## cor ## 0.9559159 상관계수 결과를 해석하자면 pvalue 값이 매우작게 0.05 보다 작게 나왔으므로, 상관관계가 0이 아니다 라는 대립가설은 통계적으로 유의하고, 상관계수 값 또한 0.95 로 나왔기 때문에, 굉장히 높은 관계가 있다고 보면 된다. 4)회귀분석1)단순회귀분석단순회귀분석은 독립변수가 1개,종속변수가 1개일 때 합니다. 회귀분석의 변수는 독립변수와 종속변수가 모두 등간척도 또는 비율척도이어야 합니다. 회귀분석은 R의 lm()함수로 합니다. 세 방법 중 어느 것을 써도 됩니다 lm(data&#x3D;데이터세트,종속변수독립변수)lm(종속변수독립변수,data&#x3D;데이터세트)lm(데이터세트$종속변수~데이터세트$독립변수) Motor trend 라는 데이터로 실습을 해볼것 인데,disp(배기량)이 mpg(연비)에 미치는 영향을 분석하겠습니다. 귀무가설:disp 는 mpg에 영향을 끼치지 않는다대립가설:disp 는 mpg에 영향을 준다.1lm(data=mtcars,mpg~disp) 1234567## ## Call:## lm(formula = mpg ~ disp, data = mtcars)## ## Coefficients:## (Intercept) disp ## 29.59985 -0.04122 Coefficients 가 -0.04122 라는 뜻은 disp가 1단위 올라갈때마다 mpg는 -0.04122 만큼 떨어진다는 뜻 입니다. 이 베타를 회귀계수라고 하며 독립변수가 종속변수에 미치는 영향을 뜻 합니다.그런데 무언가 빠진 느낌입니다. 유의수준이 없다 유의수준을 보려면 lm() 의 결과를 summary()에 넣으면 세부분석이 나온다 1summary(lm(data=mtcars,mpg~disp)) 123456789101112131415161718## ## Call:## lm(formula = mpg ~ disp, data = mtcars)## ## Residuals:## Min 1Q Median 3Q Max ## -4.8922 -2.2022 -0.9631 1.6272 7.2305 ## ## Coefficients:## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 29.599855 1.229720 24.070 &lt; 2e-16 ***## disp -0.041215 0.004712 -8.747 9.38e-10 ***## ---## Signif. codes: 0 &#x27;***&#x27; 0.001 &#x27;**&#x27; 0.01 &#x27;*&#x27; 0.05 &#x27;.&#x27; 0.1 &#x27; &#x27; 1## ## Residual standard error: 3.251 on 30 degrees of freedom## Multiple R-squared: 0.7183, Adjusted R-squared: 0.709 ## F-statistic: 76.51 on 1 and 30 DF, p-value: 9.38e-10 p-value 가 .05 보다 낮은것을 볼 수 있고 이렇게되면 회귀모형이 적합하다고 봅니다 반대로 .05 보다 크면 회귀모형에 문제가 있는 것이므로 회귀분석 자체가 성립되지 않습니다. R-squared 는 결정계수 라고 합니다. 회귀모델의 추정된 회귀식이 관측된 데이터를 설명하고 있는 비율을 계수로 나타낸 것 입니다. 결정계수는 상관계수(r) 을 제곱한 수치이며 r^2 로 표시합니다. 결정계수는 0과 1 사이에 있습니다 1에 가까울 수록 추정된 회귀선을 충족하는 표본 데이터가 많아서 추정된 회귀선의 예측 정확도와 변수 관계 설명력이 높다는 것을 의미합니다. 0에 가까울수록 회귀식과 맞지 않는 데이터가 많고, 추정된 회귀선의 예측 정확도와 변수 관계 설명력이 낮습니다. 여기서는 결정계수가 0.7183이므로 높습니다. Adjusted R-squared 는 ‘수정된 결정계수’ 입니다. 결정계수는 데이터와 독립변수가 많을수록 회귀식의 예측력과 무관하게 커지는 경향이 있어서 이를 보완한 결정계수입니다. 연구 결과에서는 수정된 결정계수를 밝히는 것이 일반적입니다. 이분석에서 수정된 결정계수는 0.709 입니다. 분석 결과는 다음과 같이 적으면 됩니다.“회귀모형은 유의수준 p&lt;.001 에서 적합하며, 회귀식의 수정된 결정계수는 .709 이다. 배기량이 연비에 미치는 회귀계수(B)는 유의수준 P&lt;.001 에서 -0.04 이다” 다중회귀분석다중회귀분석은 종속변수에 영향을 주는 독립변수가 복수일때 분석하는 방식입니다. 여러 독립변수들은 서로 영향을 주면서 종속변수에 영향을 주기 때문에 한 독립변수가 종속변수에 미치는 영향력은 단순회귀분석을 했을 때와 다중회귀분석을 했을 때에 달라집니다. 다중회귀분석에서는 단순회귀분석의 독립변수들은 +기호로 연결합니다. 방법1 lm(data&#x3D;데이터세트,종속변수~독립변수1+독립변수2)방법2 lm(종속변수~독립변수1+독립변수2,data&#x3D;데이터세트)방법3 lm(데이터$종속변수,데이터$종속변수1+데이$종속변수2)mtcars 데이터로 실습하겠습니다. mpg에는 disp(배기량) 이외에도 hp(마력)와wt(중량)이 영향을 미칠 수 있습니다. 세 독립변수가 mpg에 어떤 영향을 주는지 알아보겠습니다. 123data(&quot;mtcars&quot;)lm(data=mtcars,mpg~disp+hp+wt) 1234567## ## Call:## lm(formula = mpg ~ disp + hp + wt, data = mtcars)## ## Coefficients:## (Intercept) disp hp wt ## 37.105505 -0.000937 -0.031157 -3.800891 다중회귀식은 mpg&#x3D;37+-0.000937 * disp - 0.031157 * hp - 3.800891 * wt 입니다. 그러나 세 독립변수의 회귀계수에 대한 유의수준이 없어서 회귀계수가 유의미한 지를 알 수 없습니다. summart() 함수로 유의수준을 비롯한 상세 결과를 알아보겠습니다. 1summary(lm(data=mtcars,mpg~disp+hp+wt)) 1234567891011121314151617181920## ## Call:## lm(formula = mpg ~ disp + hp + wt, data = mtcars)## ## Residuals:## Min 1Q Median 3Q Max ## -3.891 -1.640 -0.172 1.061 5.861 ## ## Coefficients:## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 37.105505 2.110815 17.579 &lt; 2e-16 ***## disp -0.000937 0.010350 -0.091 0.92851 ## hp -0.031157 0.011436 -2.724 0.01097 * ## wt -3.800891 1.066191 -3.565 0.00133 ** ## ---## Signif. codes: 0 &#x27;***&#x27; 0.001 &#x27;**&#x27; 0.01 &#x27;*&#x27; 0.05 &#x27;.&#x27; 0.1 &#x27; &#x27; 1## ## Residual standard error: 2.639 on 28 degrees of freedom## Multiple R-squared: 0.8268, Adjusted R-squared: 0.8083 ## F-statistic: 44.57 on 3 and 28 DF, p-value: 8.65e-11 먼저 맨아래 회귀모형의 p-value 는 8.65e-11 로 회귀모형은 적합하고,변수별로 본다면 hp와 wt 는 p-value 가 유의수준 보다 낮아 허용되지만 disp는 허용되지 않습니다이는 disp 는 mpg에 영향을 주지 않고, hp와 wt만 영향을 줍니다. hp가 1단위 증가하면 mpg는 0.031157씩 감소하고, wt가 1단위씩 증가하면 mpg는 3.800891 씩 감소합니다. 앞의 단순회귀분석에서는 disp가 mgp에 정적인 영향을 주었는데, 다중회귀분석에서는 영향을 주지 않았습니다. 이같이 같은 독립변수라도 분석방법에 따라 영향력이 달라집니다. 결정계수를 보면 0.8083 으로 높아서 회귀모델의 설명력이 높습니다. 이상의 결과를 토대로 다음과 같이 적습니다“회귀모형은 유의수준 p&lt;.001에서 적합하며, 회귀식의 수정된 결정계수는.81 이다 3개 독립변수가 연비에 미치는 회귀계수 b는 hp가 .03,wt가*3.80 이었고 disp는 없었다. wt의 영향력이 가장 컸다”","categories":[{"name":"Machinelearning","slug":"Machinelearning","permalink":"https://kimyoungjae777.github.io/categories/Machinelearning/"},{"name":"통계","slug":"Machinelearning/통계","permalink":"https://kimyoungjae777.github.io/categories/Machinelearning/%ED%86%B5%EA%B3%84/"}],"tags":[{"name":"Machinelearning","slug":"Machinelearning","permalink":"https://kimyoungjae777.github.io/tags/Machinelearning/"},{"name":"통계","slug":"통계","permalink":"https://kimyoungjae777.github.io/tags/%ED%86%B5%EA%B3%84/"}],"author":"Young Jae Kim"},{"title":"SqlRound함수","slug":"sqlRound","date":"2022-01-31T00:00:00.000Z","updated":"2023-04-14T14:29:10.457Z","comments":true,"path":"2022/01/31/sqlRound/","link":"","permalink":"https://kimyoungjae777.github.io/2022/01/31/sqlRound/","excerpt":"","text":"SQL Round 함수 오라클 sql 에서 소수점 자리수를 지정하기 위해서 ROUND 함수를 사용한다. ROUND 함수는 특정 소수점을 반올림하고 나머지를 버리는 함수 이다 . 소수점을 반올림하지 않고 절사만 원한다면 TRUNC 함수를 사용해야 한다. ROUND 함수 함수: ROUND(”값”,”자리수”) 소수점 반올림 -1 (소수점 첫째자리)1234SELECT ROUND(1235.543) --① , ROUND(1235.443) --② , ROUND(1235.443, 0) --③ FROM dual 1,2,3 모두 소수점 첫번째 자리수를 반올림 한다. 즉 0번째 자리까지 나타낸다고 생가하면 된다 . 소수점 반올림 -2 (소수점 둘째자리)1234SELECT ROUND(1235.345, 1) --① , ROUND(1235.345, 2) --② , ROUND(1235.345, 3) --③ FROM dual 결론적으로 , 자릿수는 몇번째 자리까지 표시하고 반올림 하냐 이것이 중요하다 . 정수 반올림1234SELECT ROUND(1235.345, -1) --① , ROUND(1235.345, -2) --② , ROUND(1235.345, -3) --③ FROM dual ROUND 함수는 소수점 뿐만아니라 정수도 반올림이 가능하다, 그런데 정수 반올림에서는 나타내어진 자릿수에서 반올림을 실행한다.","categories":[{"name":"Development","slug":"Development","permalink":"https://kimyoungjae777.github.io/categories/Development/"},{"name":"DataBase","slug":"Development/DataBase","permalink":"https://kimyoungjae777.github.io/categories/Development/DataBase/"}],"tags":[{"name":"Development","slug":"Development","permalink":"https://kimyoungjae777.github.io/tags/Development/"},{"name":"DataBase","slug":"DataBase","permalink":"https://kimyoungjae777.github.io/tags/DataBase/"}],"author":"Young Jae Kim"},{"title":"SqlReplace함수","slug":"sqlReplace","date":"2022-01-31T00:00:00.000Z","updated":"2023-04-14T14:29:10.455Z","comments":true,"path":"2022/01/31/sqlReplace/","link":"","permalink":"https://kimyoungjae777.github.io/2022/01/31/sqlReplace/","excerpt":"","text":"SQL REPLACE 함수특정문자 치환12SELECT replace(&#x27;oracle database&#x27;,&#x27;oracle&#x27;,&#x27;ora&#x27;) AS reuslt1, replace(&#x27;oracle database&#x27;,&#x27;database&#x27;,&#x27;data&#x27;) AS result2 함수사용법Replace(”칼럼명 or 문자열”,”찾을문자”,”치환문자”) 다중 문자열 치환(중첩 Replace)12SELECT REPLACE(REPLACE(&#x27;oracle database&#x27;,&#x27;oracle&#x27;,&#x27;ora&#x27;),&#x27;database&#x27;,&#x27;data&#x27;)FROM dual; 특정문자 제거12345SELECT REPLACE(&#x27;Oracle Database&#x27;,&#x27;cle&#x27;) as result1SELECT REPLACE(&#x27;Oracle Database&#x27;,&#x27;Database&#x27;) as result2SELECT REPLACE(&#x27;Oracle Database&#x27;,&#x27;Database&#x27;,&#x27;&#x27;)as result3from dual; Replace 함수를 사용하여 특정 문자를 제거할 때는 “치환문자”항목은 생략하고”찾을문자” 만 입력하면 된다","categories":[{"name":"Development","slug":"Development","permalink":"https://kimyoungjae777.github.io/categories/Development/"},{"name":"DataBase","slug":"Development/DataBase","permalink":"https://kimyoungjae777.github.io/categories/Development/DataBase/"}],"tags":[{"name":"Development","slug":"Development","permalink":"https://kimyoungjae777.github.io/tags/Development/"},{"name":"DataBase","slug":"DataBase","permalink":"https://kimyoungjae777.github.io/tags/DataBase/"}],"author":"Young Jae Kim"},{"title":"Sql_LENGTH함수","slug":"sqlLength","date":"2022-01-31T00:00:00.000Z","updated":"2023-04-14T14:29:10.454Z","comments":true,"path":"2022/01/31/sqlLength/","link":"","permalink":"https://kimyoungjae777.github.io/2022/01/31/sqlLength/","excerpt":"","text":"SQL LENGTH 함수 문자열을 출력하는 함수 .(정확히는 BYTE길이를 가져오는 것) NAME NAME_KOREAN CHEOL SU 철수 JEONG HUN 정훈 1SELECT LENGTH(NAME),LENGTH,NAME(NAME_KOREAN) LENGTH(NAME) LENGTH,NAME(NAME_KOREAN) 8 6 9 6 NAME의 길이는 띄어쓰기를 포함하여 글자수에 +1 한 만큼 나오고 한국이름은 바이트로 표현되기때문에 6 이 나온다 CHAR_LENGTH()12SELECT CHAR_LENGTH(NAME),CHAR_LENGTH(NAME_KOREAN)FROM TABLE CHAR_LENGTH(NAME) CHAR_LENGTH(NAME_KOREAN) 8 2 9 2 문자 개수를 출력해준다 띄어쓰기도 문자이기 때문에 띄어쓰기는 포함되지만 한국이름은 2글자로 출력이 된다.","categories":[{"name":"Development","slug":"Development","permalink":"https://kimyoungjae777.github.io/categories/Development/"},{"name":"DataBase","slug":"Development/DataBase","permalink":"https://kimyoungjae777.github.io/categories/Development/DataBase/"}],"tags":[{"name":"Development","slug":"Development","permalink":"https://kimyoungjae777.github.io/tags/Development/"},{"name":"DataBase","slug":"DataBase","permalink":"https://kimyoungjae777.github.io/tags/DataBase/"}],"author":"Young Jae Kim"},{"title":"생활코딩-문자열 (19)","slug":"생활코딩-문자열 (19) d11fdd3f92d941c5a14c2322e90021d4","date":"2022-01-31T00:00:00.000Z","updated":"2023-04-14T14:29:10.472Z","comments":true,"path":"2022/01/31/생활코딩-문자열 (19) d11fdd3f92d941c5a14c2322e90021d4/","link":"","permalink":"https://kimyoungjae777.github.io/2022/01/31/%EC%83%9D%ED%99%9C%EC%BD%94%EB%94%A9-%EB%AC%B8%EC%9E%90%EC%97%B4%20(19)%20d11fdd3f92d941c5a14c2322e90021d4/","excerpt":"","text":"생활코딩-문자열 (19) 자바는 문자(Character)와 문자열(String)을 구분한다. 문자는 한 글자를 의미하고, 문자열은 여러 개의 문자가 결합한 것을 의미한다. 자바에서 문자는 ‘(작은따옴표)로 감싸야 한다. 1System.out.println(&#x27;생&#x27;); output: 생 1System.out.println(&quot;생활코딩&quot;); output: 생활코딩 1System.out.println(&#x27;생활코딩&#x27;); output error ⇒ 작은 따옴표에 문자열을 넣으면 오류가 뜬다. 1System.out.println(&quot;생&quot;); output 생 ⇒ 하나의 문자를 큰따옴표로 감싼다고 에러가 발생하지는 않는다. 한글자도 문자열이 될 수 있기 때문이다 이스케이프 만약 문자열 안에 큰 따옴표를 넣고 싶다면 어떻게 해야 할까? 1System.out.println(&quot;\\&quot;생활코딩\\&quot;이 진리다.&quot;); output “생활코딩” 이 진리다. \\를 “ 앞에 위치시키면 “ 를 문자열의 시작과 끝을 구분하는 구분자가 아니라 단순히 문자로 해석하도록 강제할 수 있다 . 이러한 기법을 escape(이스케이프) 라고 한다. 즉, 큰따옴표가 가진 문법적인 역할에서 도망친다는 뜻 이다 . 여러 줄의 표시 - \\n12System.out.println(&quot;생활코딩 \\n김영재 접수&quot;); output 생활코딩 김영재 접수","categories":[{"name":"Development","slug":"Development","permalink":"https://kimyoungjae777.github.io/categories/Development/"},{"name":"생활코딩-자바","slug":"Development/생활코딩-자바","permalink":"https://kimyoungjae777.github.io/categories/Development/%EC%83%9D%ED%99%9C%EC%BD%94%EB%94%A9-%EC%9E%90%EB%B0%94/"}],"tags":[{"name":"Development","slug":"Development","permalink":"https://kimyoungjae777.github.io/tags/Development/"},{"name":"생활코딩-자바","slug":"생활코딩-자바","permalink":"https://kimyoungjae777.github.io/tags/%EC%83%9D%ED%99%9C%EC%BD%94%EB%94%A9-%EC%9E%90%EB%B0%94/"}],"author":"Young Jae Kim"},{"title":"환율변환 프로젝트","slug":"exchangeCurrency","date":"2022-01-26T00:00:00.000Z","updated":"2023-04-14T14:29:10.443Z","comments":true,"path":"2022/01/26/exchangeCurrency/","link":"","permalink":"https://kimyoungjae777.github.io/2022/01/26/exchangeCurrency/","excerpt":"","text":"Exchange Currency Project1. 이 화면을 보고 내가 해야 하는것 . 나에게는 같은 크기 같은 기능의 exchange box 가 두개 필요하다. 그리고 그 exchange box 에는 한개의 드랍다운과 2개의 input box 가 있다 . 2. 위에 데모를 보고 깨달은 것을 토대로 index.html 을 구성해준다. 먼저 이벤트를 넣어주는 방법은 html 에서 onkeyup 처럼 넣어주는 방법이 있고, main.js 에서 넣어주는 방법이 있다. **&lt;html 에서 직접적으로 onkeyup 으로 넣어주는 인라인 기법&gt;** **&lt;main.js 에서 addEventListener 로 이벤트를 넣어주는 기법&gt;** 3. 뼈대인 html 이 완성되었으니 main.js 에서 좀더 기능을 상세하게 해주자 . 먼저, 환율을 변경해주기 위해서는, 계속해서 반복적으로 들어가는 정보이고, 연계되는 데이터일때, 객체라는 데이터타입으로 여러가지 정보를 정의해주어, 접근하기 쉽게 해준다. 12345678910111213141516171819202122232425// 값이 여러가지 정보가 들어가야 할 때 객체라는 데이터타입을 쓴다.let currencyRatio=&#123; USD:&#123; KRW:1241.00, USD:1, VND:23450.00, unit:&quot;달러&quot;, img: &quot;https://cdn-icons-png.flaticon.com/512/555/555526.png&quot;, &#125;, KRW:&#123; KRW:1, USD:0.00081, VND:18.92, unit:&quot;원&quot;, img: &quot;https://cdn.countryflags.com/thumbs/south-korea/flag-400.png&quot;, &#125;, VND:&#123; VND:1, KRW:0.053, USD:0.000043, unit:&quot;동&quot;, img: &quot;https://upload.wikimedia.org/wikipedia/commons/thumb/2/21/Flag_of_Vietnam.svg/2560px-Flag_of_Vietnam.svg.png&quot;, &#125;&#125; 이렇게 버튼이 클릭 될 때 그 버튼이 클릭된 나라의 이니셜과 국기가 나오게 코딩을 하여주어야 한다 12345678910111213141516171819 document.querySelectorAll(&quot;#from-currnecy-list a&quot;).forEach((menu)=&gt;menu.addEventListener(&quot;click&quot;,function()&#123; //2.버튼에 값을 바꾼다. textcontent 선택한 버튼의 텍스트를 들고오는것 내가 선택한 텍스트를 들고와서 이 버튼 텍스트에 넣어준다. document.getElementById(&quot;from-button&quot;).textContent=this.textContent console.log(document.getElementById(&quot;from-button&quot;).textContent) //3.선택된 currency 값을 변수에 저장해준다. //초기값 selectCurrency=this.textContent; document.getElementById(&quot;from-button&quot;).innerHTML=`&lt;img class=&quot;flag-img&quot; src=$&#123;currencyRatio[selectCurrency].img&#125;&gt;$&#123;selectCurrency&#125;` console.log(&quot;현재 선택 통화는&quot;+selectCurrency); convert();&#125;)); logic querySelectorAll 로 from-currency-list 의 id를 가진 a 태그 요소들을 다 읽는다. 그런이후, forEach를 통해서, 각각이 value 들이 클릭 되어질때 함수를 실행시킨다 함수내용 함수⇒getElementById 를 통해 id가 from-button 인 텍스트를 뽑은다음에 this에 저장을해둔다. selectCurrency&#x3D;this.textContent; 그 선택된 텍스트를 selectCurrency 로 저장을해둔다 . document.getElementById(“from-button”).innerHTML&#x3D;&lt;img class=&quot;flag-img&quot; src=$&#123;currencyRatio[selectCurrency].img&#125;&gt;$&#123;selectCurrency&#125; 를 통해, 버튼에 노출시켜준다 . 4.이제 기껏해봐야 dropdown button 에 선택된 화폐가 오는것 까지 한 것 입니다. 두번째로, convert() 함수를 사용하여 첫번째 inputbox에 환전 amount 를 넣어주었을때 , 계산되어 두번째 박스의 input에 나오게 해주는 작업을 합니다 .1234567891011function convert()&#123; let amount=document.getElementById(&quot;from-input&quot;).value commaAmount=amount.toString().replace(/\\B(?=(\\d&#123;3&#125;)+(?!\\d))/g, &#x27;,&#x27;); let convertedAmount=amount * currencyRatio[selectCurrency][toCurrency] let withComma1=convertedAmount.toLocaleString(); document.getElementById(&quot;to-input&quot;).value=convertedAmount document.getElementById(&quot;from-currency&quot;).value=commaAmount+currencyRatio[selectCurrency][&#x27;unit&#x27;] document.getElementById(&quot;to-currency&quot;).value=withComma1+currencyRatio[toCurrency][&#x27;unit&#x27;]&#125; logic12let amount=document.getElementById(&quot;from-input&quot;).valuecommaAmount=amount.toString().replace(/\\B(?=(\\d&#123;3&#125;)+(?!\\d))/g, &#x27;,&#x27;); id&#x3D;”from-input” 를 가진 input 창의 value 를 가져온다 . ⇒ 우리가 환전할 금액을 input창에 넣으면 그것이 amount에 저장이된다 commaAmount 는 amount 로 들어간 돈을 정규식을 사용하여 , 3자리마다 쉼표를 찍어주는 역역할을한다. 1let convertedAmount=amount * currencyRatio[selectCurrency][toCurrency] convertedAmount 는 입력된 amount 에 미리 객체로 만들어 놓은 [selectCurrency][toCurrency] 에 접근해 환율정보를 가져와 환율을 곱해주어 환액을 저장한다. 123document.getElementById(&quot;to-input&quot;).value=convertedAmount document.getElementById(&quot;from-currency&quot;).value=commaAmount+currencyRatio[selectCurrency][&#x27;unit&#x27;] document.getElementById(&quot;to-currency&quot;).value=withComma1+currencyRatio[toCurrency][&#x27;unit&#x27;] to-input 의 id를 가진 아래의 exchange-box 의 value ( 나타내지는 값) 에 convertedAmount 를 넣어주고 보여지게 한다. from-currency 에는 쉼표를 붙힌 commaAmount 와 객체에 접근해주어서 선택된 통화의 단위를 나오게 해준다 . Demo 결과물 .","categories":[{"name":"Development","slug":"Development","permalink":"https://kimyoungjae777.github.io/categories/Development/"},{"name":"환율계산기","slug":"Development/환율계산기","permalink":"https://kimyoungjae777.github.io/categories/Development/%ED%99%98%EC%9C%A8%EA%B3%84%EC%82%B0%EA%B8%B0/"}],"tags":[{"name":"Development","slug":"Development","permalink":"https://kimyoungjae777.github.io/tags/Development/"},{"name":"환율계산기","slug":"환율계산기","permalink":"https://kimyoungjae777.github.io/tags/%ED%99%98%EC%9C%A8%EA%B3%84%EC%82%B0%EA%B8%B0/"}],"author":"Young Jae Kim"},{"title":"비전공자를 위한 it지식","slug":"비전공자를위한IT지식","date":"2021-01-05T15:00:00.000Z","updated":"2023-04-14T14:29:10.470Z","comments":true,"path":"2021/01/06/비전공자를위한IT지식/","link":"","permalink":"https://kimyoungjae777.github.io/2021/01/06/%EB%B9%84%EC%A0%84%EA%B3%B5%EC%9E%90%EB%A5%BC%EC%9C%84%ED%95%9CIT%EC%A7%80%EC%8B%9D/","excerpt":"","text":"비전공자를 위한 이해할 수 있는 IT 지식 책에서 다루고자 하는 주제 운영체제 개발자에서 부터 프론트엔드 ~ 백엔드, git에 관련 설명 까지. 1장:프로그래밍 언어와 운영체제 개발자가 프로그래밍 언어로 컴파일러에게 보내주면 컴파일러는 이를 기계어로 바꾸어 컴퓨터에게 알려준다. IDE(Integrated Development Environment) 통합개발환경 ⇒ 개발자들의 개발을 편히도와주는 Tool 고수준 언어: 인간친화적 ⇒ 고수준언어는 인간친화적인 만큼 기계어와는 멀기 때문에 사양이 많이 필요하다 저수준 언어: 컴퓨터친화적 ⇒ 저수준언어는 컴퓨터친화적인 만큼 기계어와 가깝기 사양이 덜 필요하다 컴퓨터 하드웨어 cpu: 컴퓨터의 머리 HDD,SSD:컴퓨터의 창고 프로그램을 실행한다 ⇒HDD,SSD에 있는 프로그램을 CPU에 전달한다. 프로그램을 실행한다⇒ 하드디스크의 3번 플레터에 접근해서, 포토샵 데이터를 2번 메모리의 3번 구역에 올린뒤 CPU에게 일을시키자 ⇒ 이러한 과정이 일어나는데 이러한 과정을 운영체제가 해주는 것이다. 2장.네트워크 , 클라이언트,서버 LAN(Local Area Network)컴퓨터가 연결된 작은지역 MAN(MetroPolitan Area Network):도시의 여러LAN을 하나로 연결 WAN(Wide Area Network):나라와 나라를 연결 IP:컴퓨터의 주소로써 컴퓨터가 늘어날수록 IP 많이 필요 플레이 스토어에서 카카오톡을 다운받으면 생기는 일 여기서 나의 스마트폰은 클라이언트가 되는것 이고, 애플이 켜놓은 컴퓨터는 서버가 되는것 이다. 도대체 우분투가 뭐죠? 우분투는 리눅스(운영체제)의 한 버젼으로, 리눅스는 무료이기 때문에 리눅스 초기버젼을 발전시켜 새롭게 나온 버젼이고 사람들이 제일 많이 쓰는 버젼이다 3장 API와 JSONPOST는 뭐고 GET은 뭐죠?API &#x3D; 서버는 요청에 따라 적합한 처리를 해서 응답을 준다. 하지만 컴퓨터는 한글을 모릅니다. 어떤 요청이 ‘메세지를 달라’는 요청인지, ‘로그인 시켜줘’ 라는 요청인지 알 수 없습니다. 요청을 구분할 수 있도록 하는 ‘체계’가 API이다 API는 클라이언트,서버와 같은 서로 다른 프로그램에서 요청과 응답을 주고 받을 수 있게 만든 체계입니다. API에는 형식이 있는데 가장 많이쓰는 형식이 JSON이다. API 문서 읽는 방법 API제목 : GET_CAKES →케이크를 달라는 API에 관해서 설명하는 문서. 파란색 GET: 클라이언트에서 서버로 요청을 보낼때,GET 요청으로 보내는 것이다 ⇒ READ(조회) 의미 API주소: 컴퓨터의 위치 REQUEST,RESPONE : REQUEST 일때랑 RESPONSE 일때랑 문서를 나누어 놓은것 PARAMETER : 요청을 보낼때 필요한 변수 부문 200번대 요청이 성공하였을때 400번대 500번대 요청이 실패하였을때 프레임워크와 라이브러리프레임워크 원하는 기능 구현에 집중하여 개발할 수 있도록 일정한 형태와 필요한 기능을 갖추고 있는 골격,뼈대를 의미 한다. 애플리케이션 개발 시 필수적인 코드, 알고리즘,DB 연동과 같은 기능들을 위해 어느정도 뼈대를 제공 하며 이러한 뼈대 위에서 사용자는 코드를 작성하여 애플리케이션을 개발한다. 앱&#x2F;서버 등의 구동, 메모리관리,이벤트 루프 등의 공통된 부분은 프레임워크가 관리하며, 사용자는 프레임워크가 정해준 방식대로 클래스,케서드를 구현하면 된다. EX) Java 서버 개발에 사용되는 Spring Python 서버 개발에 사용되는 Django, Flask 안드로이드 앱 개발에 사용되는 Android 아이폰 앱 개발에 사용되는 Cocoa Touch 웹 개발에 사용되는 Angular, Vue.js 등 자바 기반의 JSP를 위한 프레임 워크 Struts 루비로 작성된 MVC패턴을 이용하는 Ruby on Rails 라이브러리 소프트웨어를 개발할 때 컴퓨터 프로그램이 사용하는 비휘발성 자원의 모임. 즉 특정 기능을 모와둔 코드, 함수들의 집합이며 코드 작성 시 활용 가능한 도구들을 의미합니다. EX) Python pip로 설치한 패키지&#x2F;모듈 (tensorflow, pandas, beautifulsoup 등등) C++의 표준 템플릿 라이브러리 (STL) Node.js에서 npm으로 설치한 모듈 HTML의 클라이언트 사이드 조작을 단순화하는 JQuery 웹에서 사용자 인터페이스 개발에 사용되는 React.js","categories":[{"name":"Book","slug":"Book","permalink":"https://kimyoungjae777.github.io/categories/Book/"}],"tags":[],"author":"Young Jae Kim"}],"categories":[{"name":"Development","slug":"Development","permalink":"https://kimyoungjae777.github.io/categories/Development/"},{"name":"SqlZoo","slug":"Development/SqlZoo","permalink":"https://kimyoungjae777.github.io/categories/Development/SqlZoo/"},{"name":"git_error","slug":"Development/git-error","permalink":"https://kimyoungjae777.github.io/categories/Development/git-error/"},{"name":"기본개념","slug":"Development/기본개념","permalink":"https://kimyoungjae777.github.io/categories/Development/%EA%B8%B0%EB%B3%B8%EA%B0%9C%EB%85%90/"},{"name":"Verdeterr(웹프로젝트)","slug":"Development/Verdeterr-웹프로젝트","permalink":"https://kimyoungjae777.github.io/categories/Development/Verdeterr-%EC%9B%B9%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/"},{"name":"DataBase","slug":"Development/DataBase","permalink":"https://kimyoungjae777.github.io/categories/Development/DataBase/"},{"name":"Book","slug":"Book","permalink":"https://kimyoungjae777.github.io/categories/Book/"},{"name":"Machinelearning","slug":"Machinelearning","permalink":"https://kimyoungjae777.github.io/categories/Machinelearning/"},{"name":"알고리즘","slug":"Machinelearning/알고리즘","permalink":"https://kimyoungjae777.github.io/categories/Machinelearning/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"데이터분석","slug":"데이터분석","permalink":"https://kimyoungjae777.github.io/categories/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B6%84%EC%84%9D/"},{"name":"gitBlog","slug":"Development/gitBlog","permalink":"https://kimyoungjae777.github.io/categories/Development/gitBlog/"},{"name":"통계","slug":"Machinelearning/통계","permalink":"https://kimyoungjae777.github.io/categories/Machinelearning/%ED%86%B5%EA%B3%84/"},{"name":"생활코딩-자바","slug":"Development/생활코딩-자바","permalink":"https://kimyoungjae777.github.io/categories/Development/%EC%83%9D%ED%99%9C%EC%BD%94%EB%94%A9-%EC%9E%90%EB%B0%94/"},{"name":"환율계산기","slug":"Development/환율계산기","permalink":"https://kimyoungjae777.github.io/categories/Development/%ED%99%98%EC%9C%A8%EA%B3%84%EC%82%B0%EA%B8%B0/"}],"tags":[{"name":"Development","slug":"Development","permalink":"https://kimyoungjae777.github.io/tags/Development/"},{"name":"SQLZOO","slug":"SQLZOO","permalink":"https://kimyoungjae777.github.io/tags/SQLZOO/"},{"name":"Machinelearning","slug":"Machinelearning","permalink":"https://kimyoungjae777.github.io/tags/Machinelearning/"},{"name":"git_error","slug":"git-error","permalink":"https://kimyoungjae777.github.io/tags/git-error/"},{"name":"기본개념","slug":"기본개념","permalink":"https://kimyoungjae777.github.io/tags/%EA%B8%B0%EB%B3%B8%EA%B0%9C%EB%85%90/"},{"name":"Verdeterr(웹프로젝트)","slug":"Verdeterr-웹프로젝트","permalink":"https://kimyoungjae777.github.io/tags/Verdeterr-%EC%9B%B9%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/"},{"name":"DataBase","slug":"DataBase","permalink":"https://kimyoungjae777.github.io/tags/DataBase/"},{"name":"알고리즘","slug":"알고리즘","permalink":"https://kimyoungjae777.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"gitBlog","slug":"gitBlog","permalink":"https://kimyoungjae777.github.io/tags/gitBlog/"},{"name":"통계","slug":"통계","permalink":"https://kimyoungjae777.github.io/tags/%ED%86%B5%EA%B3%84/"},{"name":"생활코딩-자바","slug":"생활코딩-자바","permalink":"https://kimyoungjae777.github.io/tags/%EC%83%9D%ED%99%9C%EC%BD%94%EB%94%A9-%EC%9E%90%EB%B0%94/"},{"name":"환율계산기","slug":"환율계산기","permalink":"https://kimyoungjae777.github.io/tags/%ED%99%98%EC%9C%A8%EA%B3%84%EC%82%B0%EA%B8%B0/"}]}